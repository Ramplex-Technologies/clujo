{"version":3,"sources":["../src/clujo.ts","../src/task-graph-builder.ts","../src/context.ts","../src/task-graph.ts","../src/cron.ts","../src/clujo-builder.ts"],"sourcesContent":["import type { Redis } from \"ioredis\";\nimport { type LockOptions, Mutex } from \"redis-semaphore\";\nimport type { IClujo, ILock, StartOptions, TErrorHandler, TExecute } from \"./clujo.types\";\nimport type { ICron } from \"./cron.types\";\nimport { TaskGraphBuilder } from \"./task-graph-builder\";\nimport type { ITask, ITaskGraph, ITaskGraphBuilderHelper, RetryPolicy, TaskMap } from \"./task-graph.types\";\n\nexport class Clujo<TDependencies, TContext extends object, TTaskMap extends TaskMap<TDependencies, TContext>>\n  implements IClujo<TDependencies, TContext, TTaskMap>\n{\n  private readonly taskGraphBuilder: ITaskGraphBuilderHelper<TDependencies, TContext, TTaskMap>;\n  private taskGraph: ITaskGraph<TContext> | undefined;\n  private hasStarted = false;\n\n  constructor(\n    public readonly id: string,\n    private readonly cron: ICron,\n    private readonly retryPolicy: RetryPolicy,\n    private readonly runImmediately: boolean,\n    dependencies: TDependencies,\n    contextValueOrFactory: undefined | TContext | (() => TContext | Promise<TContext>),\n  ) {\n    this.taskGraphBuilder = new TaskGraphBuilder<TDependencies, TContext>()\n      .setDependencies(dependencies)\n      .setInitialContext(contextValueOrFactory)\n      .finalizeSetup();\n  }\n\n  addTask<TTaskId extends string, TExecuteReturn>(input: {\n    taskId: TTaskId;\n    // pick the keys of TTaskMap in TContext\n    execute: TExecute<TDependencies, TContext, TExecuteReturn>;\n    errorHandler?: TErrorHandler<TDependencies, TContext>;\n    retryPolicy?: RetryPolicy;\n    dependencies?: (keyof TTaskMap)[];\n  }): IClujo<\n    TDependencies,\n    TContext &\n      Partial<{\n        [K in TTaskId]: TExecuteReturn extends void ? undefined : TExecuteReturn;\n      }>,\n    TTaskMap & {\n      [K in TTaskId]: ITask<\n        TDependencies,\n        TExecuteReturn,\n        TContext &\n          Partial<{\n            [K in TTaskId]: TExecuteReturn extends void ? undefined : TExecuteReturn;\n          }>\n      >;\n    }\n  > {\n    if (this.hasStarted) throw new Error(\"Cannot add a task after the Clujo has started.\");\n    this.taskGraphBuilder.addTask({\n      id: input.taskId,\n      execute: input.execute,\n      errorHandler: input.errorHandler,\n      retryPolicy: input.retryPolicy ?? this.retryPolicy,\n      dependencies: input.dependencies as string[] | undefined,\n    });\n    return this as unknown as IClujo<\n      TDependencies,\n      TContext & { [K in TTaskId]: TExecuteReturn extends void ? undefined : TExecuteReturn },\n      TTaskMap & {\n        [K in TTaskId]: ITask<\n          TDependencies,\n          TExecuteReturn,\n          TContext & { [K in TTaskId]: TExecuteReturn extends void ? undefined : TExecuteReturn }\n        >;\n      }\n    >;\n  }\n\n  start(options?: StartOptions<TContext>): IClujo<TDependencies, TContext, TTaskMap> {\n    if (this.hasStarted) throw new Error(\"Cannot start a Clujo that has already been started.\");\n    if (!this.taskGraphBuilder.size) throw new Error(\"Cannot start a Clujo with no added tasks.\");\n    // run the topological sort when starting as this is now a finalized task graph (graph invoked with trigger before start may no longer be valid)\n    this.taskGraph = this.taskGraphBuilder.build();\n    const redis = options?.redis;\n\n    const executeTasksAndCompletionHandler = async () => {\n      if (!this.taskGraph) throw new Error(\"Task graph not initialized\");\n      const finalContext = await this.taskGraph.run();\n      if (options?.completionHandler) await options.completionHandler(finalContext);\n    };\n\n    const handler = async () => {\n      try {\n        if (!redis) {\n          await executeTasksAndCompletionHandler();\n        } else {\n          await using lock = await this.tryAcquire(redis, options?.options);\n          if (lock) {\n            await executeTasksAndCompletionHandler();\n          }\n        }\n      } catch (error) {\n        console.error(`Clujo ${this.id} failed: ${error}`);\n      }\n    };\n    this.cron.start(handler);\n    this.hasStarted = true;\n    if (this.runImmediately) this.trigger();\n    return this;\n  }\n\n  async stop(timeout = 5000): Promise<void> {\n    if (!this.hasStarted) throw new Error(\"Cannot stop a Clujo that has not been started.\");\n    await this.cron.stop(timeout);\n  }\n\n  async trigger(): Promise<Required<TContext>> {\n    if (!this.taskGraphBuilder.size) throw new Error(\"Cannot trigger a Clujo with no added tasks.\");\n    if (!this.taskGraph) this.taskGraph = this.taskGraphBuilder.build();\n    return await this.taskGraph.run();\n  }\n\n  private async tryAcquire(redis: Redis, lockOptions: LockOptions | undefined): Promise<ILock | null> {\n    const mutex = new Mutex(redis, this.id, lockOptions);\n    const lock = await mutex.tryAcquire();\n    if (!lock) return null;\n    return {\n      mutex,\n      [Symbol.asyncDispose]: async () => {\n        try {\n          await mutex.release();\n        } catch (error) {\n          console.error(`Error releasing lock for Clujo ${this.id}: ${error}`);\n        }\n      },\n    };\n  }\n}\n","import { promisify } from \"node:util\";\nimport { TaskGraph } from \"./task-graph\";\nimport type {\n  ITask,\n  ITaskGraph,\n  ITaskGraphBuilder,\n  ITaskGraphBuilderHelper,\n  RetryPolicy,\n  TaskMap,\n  TaskOptions,\n  TaskStatus,\n} from \"./task-graph.types\";\n\nconst sleep = promisify(setTimeout);\n\nclass Task<TCommonInput, TContextInput, TReturn> implements ITask<TCommonInput, TContextInput, TReturn> {\n  private readonly _dependencies: string[] = [];\n  private _retryPolicy: RetryPolicy = { maxRetries: 0, retryDelayMs: 0 };\n  private _status: TaskStatus = \"pending\";\n\n  constructor(\n    private readonly options: TaskOptions<string, TCommonInput, TContextInput, TReturn, string | number | symbol>,\n  ) {\n    if (options.retryPolicy) this._retryPolicy = options.retryPolicy;\n  }\n\n  public get id() {\n    return this.options.id;\n  }\n\n  public get status() {\n    return this._status;\n  }\n\n  public get dependencies() {\n    return this._dependencies;\n  }\n\n  public addDependency(taskId: string) {\n    this._dependencies.push(taskId);\n  }\n\n  public async run(deps: TCommonInput, ctx: TContextInput): Promise<TReturn> {\n    // we retry maxRetries times on top of the initial attempt\n    for (let attempt = 0; attempt < this._retryPolicy.maxRetries + 1; attempt++) {\n      try {\n        const result = await this.options.execute({ deps, ctx });\n        this._status = \"completed\";\n        return result;\n      } catch (err) {\n        if (attempt === this._retryPolicy.maxRetries) {\n          console.error(`Task failed after ${attempt + 1} attempts: ${err}`);\n          const error = err instanceof Error ? err : new Error(`Non error throw: ${String(err)}`);\n          try {\n            if (this.options.errorHandler) await this.options.errorHandler(error, { deps, ctx });\n            else console.error(`Error in task ${this.options.id}: ${err}`);\n          } catch (error) {\n            console.error(`Error in task error handler for ${this.options.id}: ${error}`);\n          }\n          this._status = \"failed\";\n          throw error;\n        }\n        console.error(`Task failed, retrying (attempt ${attempt + 1}/${this._retryPolicy.maxRetries}): ${err}`);\n        await sleep(this._retryPolicy.retryDelayMs);\n      }\n    }\n\n    // This line should never be reached due to the for loop condition,\n    // but TypeScript requires a return statement here\n    throw new Error(\"Unexpected end of run method\");\n  }\n}\n\nexport class TaskGraphBuilder<TDependencies, TContext extends object>\n  implements ITaskGraphBuilder<TDependencies, TContext>\n{\n  private contextValueOrFactory: unknown = undefined;\n  private dependencies!: TDependencies;\n\n  finalizeSetup() {\n    // biome-ignore lint/complexity/noBannedTypes: <explanation>\n    return new TaskGraphBuilderHelper<TDependencies, TContext, {}>(\n      this.dependencies,\n      this.contextValueOrFactory as undefined | TContext | (() => TContext | Promise<TContext>),\n    );\n  }\n\n  setDependencies<TNewDependencies>(value?: undefined | TNewDependencies) {\n    this.dependencies = value as unknown as TDependencies;\n    return this as unknown as ITaskGraphBuilder<TNewDependencies, TContext>;\n  }\n\n  setInitialContext<TNewContext extends object>(\n    valueOrFactory?: undefined | TNewContext | (() => TNewContext | Promise<TNewContext>),\n  ) {\n    this.contextValueOrFactory = valueOrFactory;\n    return this as unknown as ITaskGraphBuilder<TDependencies, TNewContext>;\n  }\n}\n\nexport class TaskGraphBuilderHelper<\n  TDependencies,\n  TContext extends object,\n  TTaskMap extends TaskMap<TDependencies, TContext>,\n> implements ITaskGraphBuilderHelper<TDependencies, TContext, TTaskMap>\n{\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  private readonly tasks: Map<string, ITask<TDependencies, TContext, any>> = new Map();\n  private readonly order: string[] = [];\n\n  constructor(\n    private readonly dependencies: TDependencies,\n    private readonly contextValueOrFactory: undefined | TContext | (() => TContext | Promise<TContext>),\n  ) {}\n\n  public get size() {\n    return this.tasks.size;\n  }\n\n  build(): ITaskGraph<TContext> {\n    this.topologicalSort();\n    return new TaskGraph(this.dependencies, this.contextValueOrFactory, this.tasks, this.order);\n  }\n\n  addTask<TTaskId extends string, TReturn>(\n    options: TaskOptions<TTaskId, TDependencies, TContext, TReturn, keyof TTaskMap>,\n  ): ITaskGraphBuilderHelper<\n    TDependencies,\n    TContext & Partial<{ [K in TTaskId]: TReturn }>,\n    TTaskMap & { [K in TTaskId]: ITask<TDependencies, TContext & Partial<{ [K in TTaskId]: TReturn }>, TReturn> }\n  > {\n    const taskId = options.id;\n    if (this.tasks.has(taskId)) {\n      throw new Error(`Task with id ${taskId} already exists`);\n    }\n    const task = new Task(options);\n    this.tasks.set(taskId, task);\n\n    for (const depId of options.dependencies ?? []) {\n      if (typeof depId !== \"string\") throw new Error(\"Dependency ID must be a string\");\n      const dependentTask = this.tasks.get(depId);\n      if (!dependentTask) throw new Error(`Dependency ${depId} not found for task ${taskId}`);\n      task.addDependency(depId);\n    }\n\n    return this as unknown as ITaskGraphBuilderHelper<\n      TDependencies,\n      TContext & Partial<{ [K in TTaskId]: TReturn }>,\n      TTaskMap & { [K in TTaskId]: ITask<TDependencies, TContext & Partial<{ [K in TTaskId]: TReturn }>, TReturn> }\n    >;\n  }\n\n  private topologicalSort() {\n    const visited = new Set<string>();\n    const temp = new Set<string>();\n\n    const visit = (taskId: string) => {\n      if (temp.has(taskId)) {\n        throw new Error(`Circular dependency detected involving task ${taskId}`);\n      }\n      if (!visited.has(taskId)) {\n        temp.add(taskId);\n        const task = this.tasks.get(taskId);\n        if (!task) throw new Error(`Task ${taskId} not found`);\n\n        for (const depId of task.dependencies) {\n          visit(depId);\n        }\n\n        temp.delete(taskId);\n        visited.add(taskId);\n        this.order.push(taskId);\n      }\n    };\n\n    for (const taskId of this.tasks.keys()) {\n      if (!visited.has(taskId)) {\n        visit(taskId);\n      }\n    }\n  }\n}\n","/**\n * Used to allow for the sharing of state between tasks.\n */\nexport class Context<T extends object> {\n  private object!: { initial: object | undefined } & T;\n  private updateQueue: Promise<void>;\n\n  constructor(initialObject?: object) {\n    this.reset(initialObject);\n    this.updateQueue = Promise.resolve();\n  }\n\n  /**\n   * Gets the current state of the managed object.\n   */\n  public get value(): { initial: object | undefined } & T {\n    return this.object;\n  }\n\n  /**\n   * Resets the context to its initial state or a new initial object.\n   */\n  public reset(initialObject?: object): void {\n    if (initialObject) {\n      this.object = { initial: { ...initialObject } } as {\n        initial: object | undefined;\n      } & T;\n    } else {\n      this.object = { initial: undefined } as {\n        initial: object | undefined;\n      } & T;\n    }\n  }\n\n  /**\n   * Asynchronously updates the context with new values. Ensures that updates are applied in the order they are called.\n   */\n  public update<NewValue extends object>(updateValue: NewValue): Promise<void> {\n    this.updateQueue = this.updateQueue.then(() => {\n      // overrides won't happen with how this is used since\n      // the initial context is under the key \"initial\"\n      // and all task results are under the unique id of that task\n      this.object = { ...this.object, ...updateValue };\n      return Promise.resolve();\n    });\n    return this.updateQueue;\n  }\n}\n","import { Context } from \"./context\";\nimport type { ITask, ITaskGraph } from \"./task-graph.types\";\n\nexport class TaskGraph<TDependencies, TContext extends object> implements ITaskGraph<TContext> {\n  private readonly context: Context<TContext> = new Context<TContext>();\n\n  constructor(\n    private readonly taskDependencies: TDependencies,\n    private readonly contextValueOrFactory: undefined | TContext | (() => TContext | Promise<TContext>),\n    private readonly tasks: Map<string, ITask<TDependencies, TContext, unknown>>,\n    private readonly order: string[],\n  ) {}\n\n  run = async (): Promise<Required<TContext>> => {\n    if (this.order.length === 0) throw new Error(\"No tasks to run. Did you forget to call topologicalSort?\");\n    let value: TContext | undefined;\n    if (this.contextValueOrFactory) {\n      value =\n        typeof this.contextValueOrFactory === \"function\"\n          ? await this.contextValueOrFactory()\n          : this.contextValueOrFactory;\n    }\n    this.context.reset(value);\n\n    const completed = new Set<string>();\n    const running = new Map<string, Promise<void>>();\n    const readyTasks = new Set<string>(\n      this.order.filter((taskId) => this.tasks.get(taskId)?.dependencies.length === 0),\n    );\n\n    const runTask = async (taskId: string) => {\n      const task = this.tasks.get(taskId);\n      if (!task) throw new Error(`Task ${taskId} not found`);\n\n      try {\n        const result = await task.run(this.taskDependencies, this.context.value);\n        await this.context.update({ [taskId]: result });\n        completed.add(taskId);\n      } catch {\n        // completed in the sense that we won't try to run it again\n        completed.add(taskId);\n      } finally {\n        running.delete(taskId);\n\n        // Check if any dependent tasks are now ready to run\n        for (const [id, t] of this.tasks) {\n          if (!completed.has(id) && !running.has(id)) {\n            const canRun = t.dependencies.every((depId) => {\n              const depTask = this.tasks.get(depId);\n              return depTask && completed.has(depId) && depTask.status === \"completed\";\n            });\n            if (canRun) readyTasks.add(id);\n          }\n        }\n      }\n    };\n\n    while (completed.size < this.tasks.size) {\n      // Start all ready tasks\n      for (const taskId of readyTasks) {\n        readyTasks.delete(taskId);\n        const promise = runTask(taskId);\n        running.set(taskId, promise);\n      }\n\n      // Wait for at least one task to complete\n      if (running.size > 0) {\n        await Promise.race(running.values());\n      } else {\n        // no tasks are running and we have not completed all tasks\n        // happens when tasks could not run due to failed dependencies\n        break;\n      }\n    }\n\n    return this.context.value as Required<TContext>;\n  };\n}\n","import Croner, { type CronOptions } from \"croner\";\nimport type { ICron } from \"./cron.types\";\n\nexport class Cron implements ICron {\n  private job: Croner | null = null;\n\n  constructor(\n    private readonly cronExpression: string,\n    private readonly cronOptions?: CronOptions,\n  ) {}\n\n  start(handler: () => Promise<void> | void): void {\n    if (this.job) throw new Error(\"Attempting to start an already started job\");\n    this.job = new Croner(this.cronExpression, this.cronOptions, handler);\n  }\n\n  stop(timeout: number): Promise<void> {\n    return new Promise<void>((resolve) => {\n      const startTime = Date.now();\n      const checkAndStop = () => {\n        if (!this.job) {\n          resolve(); // resolve if job has cleared\n          return;\n        }\n\n        if (this.job.isBusy()) {\n          if (Date.now() - startTime > timeout) {\n            this.job.stop();\n            this.job = null;\n            resolve();\n            return;\n          }\n          setTimeout(checkAndStop, 100);\n        } else {\n          this.job.stop();\n          this.job = null;\n          resolve();\n        }\n      };\n\n      checkAndStop();\n    });\n  }\n}\n","import type { CronOptions } from \"croner\";\nimport { Clujo } from \"./clujo\";\nimport type { IClujo, IClujoBuilder, IClujoStart } from \"./clujo.types\";\nimport { Cron } from \"./cron\";\nimport type { ICron } from \"./cron.types\";\nimport type { RetryPolicy } from \"./task-graph.types\";\n\n/**\n * A builder class for creating and configuring a Clujo instance.\n *\n * @implements {IClujoStart}\n *\n * @description\n * The ClujoBuilder provides a fluent interface for setting up a Clujo with various configurations.\n * It allows you to define the schedule, set dependencies, configure the context, and apply retry policies.\n *\n * @example\n * ```typescript\n * const clujo = new ClujoBuilder('myClujoId')\n *   .setSchedule('* * * * *')                                // cron schedule to run on\n *   .setDependencies({ db: myDatabase })                     // every task has access to the database\n *   .setContext({ initialValue: 0 })                         // initial context value (can also be a function returning a value)\n *   .setRetryPolicy({ maxRetries: 3, retryDelayMs: 1000 })   // global retry policy (can be overriden by task)\n *   .runOnStartup()                                          // run this task immediately when the Clujo starts\n *   .build();                                                // build the Clujo instance -- tasks can now be added\n * ```\n *\n * @see {@link IClujoStart} for the initial interface implemented by ClujoBuilder.\n * @see {@link IClujoBuilder} for the interface returned after setting the schedule.\n * @see {@link IClujo} for the final Clujo interface after building.\n */\nexport class ClujoBuilder implements IClujoStart {\n  constructor(private readonly id: string) {}\n\n  setSchedule(pattern: string, options?: CronOptions): IClujoBuilder<void, { initial: undefined }> {\n    // TODO: validate this pattern?\n    const cron = new Cron(pattern, options);\n    return new ClujoBuilderHelper(this.id, cron);\n  }\n}\n\nclass ClujoBuilderHelper<TDependencies, TContext extends object> implements IClujoBuilder<TDependencies, TContext> {\n  // do not retry by default\n  private retryPolicy: RetryPolicy = { maxRetries: 0, retryDelayMs: 0 };\n  // do not run immediately by default\n  private runImmediately = false;\n  // do not set initial context by default\n  private contextValueOrFactory: unknown = undefined;\n  private dependencies!: TDependencies;\n\n  constructor(\n    private readonly id: string,\n    private readonly cron: ICron,\n  ) {}\n\n  // biome-ignore lint/complexity/noBannedTypes: valid use case here\n  build(): IClujo<TDependencies, TContext, {}> {\n    // biome-ignore lint/complexity/noBannedTypes: valid use case here\n    return new Clujo<TDependencies, TContext, {}>(\n      this.id,\n      this.cron,\n      this.retryPolicy,\n      this.runImmediately,\n      this.dependencies,\n      this.contextValueOrFactory as undefined | TContext | (() => TContext | Promise<TContext>),\n    );\n  }\n\n  runOnStartup(): IClujoBuilder<TDependencies, TContext> {\n    this.runImmediately = true;\n    return this;\n  }\n\n  setDependencies<TNewDeps extends object>(deps: TNewDeps): IClujoBuilder<TNewDeps, TContext> {\n    this.dependencies = deps as unknown as TDependencies;\n    return this as unknown as IClujoBuilder<TNewDeps, TContext>;\n  }\n\n  setInitialContext<TNewContext>(\n    valueOrFactory: TNewContext | (() => TNewContext | Promise<TNewContext>),\n  ): IClujoBuilder<TDependencies, { initial: TNewContext }> {\n    this.contextValueOrFactory = valueOrFactory;\n    return this as unknown as IClujoBuilder<TDependencies, { initial: TNewContext }>;\n  }\n\n  setRetryPolicy(policy: RetryPolicy): IClujoBuilder<TDependencies, TContext> {\n    this.retryPolicy = policy;\n    return this;\n  }\n}\n"],"mappings":"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","names":["error"]}