{"version":3,"sources":["../src/task-graph.types.ts"],"sourcesContent":["export type RetryPolicy = {\n  /**\n   * The maximum number of retry attempts after the initial attempt.\n   * If set to 0, no retries will be performed.\n   */\n  maxRetries: number;\n  /**\n   * The delay in milliseconds between retry attempts.\n   * This delay is applied before each retry attempt.\n   */\n  retryDelayMs: number;\n};\n\nexport interface TaskOptions<TTaskId extends string, TDependencies, TContextInput, TReturn, TDependencyIds> {\n  /**\n   * Unique identifier for the task.\n   * This ID is used to reference the task in dependencies and results.\n   */\n  id: TTaskId;\n  /**\n   * Array of task IDs that this task depends on.\n   * The task will only execute after all its dependencies have completed successfully.\n   */\n  dependencies?: TDependencyIds[];\n  /**\n   * Configuration for retry behavior in case of task failure.\n   * If not provided, the task will use the default retry policy (if any) set at the graph level.\n   */\n  retryPolicy?: RetryPolicy;\n  /**\n   * Function to execute the task, receiving common dependencies and context as input.\n   *\n   * @param input - An object containing the task's input.\n   * @param input.deps - The common dependencies shared across all tasks.\n   * @param input.ctx - The current context, including results from completed dependent tasks.\n   * @returns A promise that resolves with the task's result, or the result directly.\n   */\n  execute: (input: { deps: TDependencies; ctx: TContextInput }) => Promise<TReturn> | TReturn;\n  /**\n   * Optional error handler function called when the task fails after all retry attempts.\n   *\n   * @param err - The error that caused the task to fail.\n   * @param input - An object containing the task's input at the time of failure.\n   * @param input.deps - The common dependencies shared across all tasks.\n   * @param input.ctx - The current context at the time of failure.\n   */\n  errorHandler?: (err: Error, input: { deps: TDependencies; ctx: TContextInput }) => Promise<void> | void;\n}\n\nexport type TaskStatus = \"pending\" | \"running\" | \"completed\" | \"failed\";\n\nexport interface ITask<TDependencies, TContextInput, TReturn> {\n  /**\n   * Unique identifier for the task.\n   * This ID is used to reference the task in dependencies and results.\n   */\n  id: string;\n  /**\n   * Current status of the task.\n   */\n  status: TaskStatus;\n  /**\n   * Array of task IDs that this task depends on.\n   * The task will only execute after all its dependencies have completed successfully.\n   */\n  dependencies: string[];\n  /**\n   * Adds a dependency to the task.\n   *\n   * @param taskId - The ID of the task to add as a dependency.\n   */\n  addDependency(taskId: string): void;\n  /**\n   * Executes the task with the given dependencies and context.\n   *\n   * @param dependencies - The common dependencies shared across all tasks.\n   * @param context - The current context, including results from completed dependent tasks.\n   * @returns A promise that resolves with the task's result.\n   */\n  run(dependencies: TDependencies, context: TContextInput): Promise<TReturn>;\n}\n\nexport type TaskMap<TDependencies, TContext> = {\n  // biome-ignore lint/suspicious/noExplicitAny: unknown return ahead of time\n  [key: string]: ITask<TDependencies, TContext, any>;\n};\n\nexport interface ITaskGraphBuilder<TDependencies, TContext> {\n  /**\n   * Finalizes the setup and returns a TaskGraphBuilderHelper.\n   * Once invoked, the context and dependencies types are locked in.\n   *\n   * @returns A new ITaskGraphBuilderHelper instance with the current dependencies and context types.\n   */\n  // biome-ignore lint/complexity/noBannedTypes: any task map here\n  finalizeSetup(): ITaskGraphBuilderHelper<TDependencies, TContext, {}>;\n\n  /**\n   * Sets the dependencies for the task graph.\n   * These dependencies will be available to all tasks in the graph.\n   *\n   * @template TNewDependencies The type of the new dependencies, which must be an object.\n   * @param value - The dependencies object to be used across all tasks in the graph.\n   * @returns A new ITaskGraphBuilder with updated dependencies type.\n   */\n  setDependencies<TNewDependencies extends object>(\n    value?: TNewDependencies,\n  ): ITaskGraphBuilder<TNewDependencies, TContext>;\n\n  /**\n   * Sets the initial context for the task graph.\n   * This context will be passed to the first task(s) in the graph.\n   *\n   * @template TNewContext The type of the new context, which must be an object.\n   * @param valueOrFactory - The initial context value or a factory function to create it.\n   *                         If a function is provided, it can be synchronous or asynchronous.\n   * @returns A new ITaskGraphBuilder with updated context type.\n   */\n  setInitialContext<TNewContext extends object>(\n    valueOrFactory?: TNewContext | (() => TNewContext | Promise<TNewContext>),\n  ): ITaskGraphBuilder<TDependencies, TNewContext>;\n}\n\nexport interface ITaskGraphBuilderHelper<TDependencies, TContext, TTaskMap extends TaskMap<TDependencies, TContext>> {\n  /**\n   * Adds a new task to the task graph.\n   *\n   * @remarks\n   * - The task's result will be added to the context under the key of its task ID.\n   * - If the task has no return value, undefined will be added to the context.\n   * - Tasks can depend on other tasks, forming a directed acyclic graph (DAG).\n   * - Circular dependencies will result in an error during graph construction.\n   *\n   * @template TTaskId The type of the task ID, which must be a string.\n   * @template TReturn The return type of the task.\n   * @param options - The options for creating the task.\n   * @returns A new ITaskGraphBuilderHelper with the added task and updated context type.\n   * @throws {Error} If a task with the same ID already exists.\n   */\n  addTask<TTaskId extends string, TReturn>(\n    options: TaskOptions<TTaskId, TDependencies, TContext, TReturn, keyof TTaskMap>,\n  ): ITaskGraphBuilderHelper<\n    TDependencies,\n    TContext &\n      Partial<{\n        [K in TTaskId]: TReturn;\n      }>,\n    TTaskMap & {\n      [K in TTaskId]: ITask<\n        TDependencies,\n        TContext &\n          Partial<{\n            [K in TTaskId]: TReturn;\n          }>,\n        TReturn\n      >;\n    }\n  >;\n\n  /**\n   * Builds and returns the final task graph.\n   *\n   * @remarks\n   * - This method finalizes the graph construction and performs topological sorting of tasks.\n   * - After calling this method, no more tasks can be added to the graph.\n   *\n   * @returns The constructed ITaskGraph ready for execution.\n   * @throws {Error} If circular dependencies are detected during graph construction.\n   */\n  build(): ITaskGraph<TContext>;\n\n  /**\n   * The number of tasks currently in the graph.\n   *\n   * @remarks\n   * This property can be used to check if any tasks have been added to the graph.\n   */\n  size: number;\n}\n\nexport interface ITaskGraph<TContext> {\n  /**\n   * Executes all tasks in the graph and returns the final context.\n   *\n   * @remarks\n   * - Tasks are executed based on their dependencies, with independent tasks potentially running in parallel.\n   * - The execution follows the topological order of the task graph.\n   * - If a task fails and has no retry policy or exceeds its retry attempts, the graph execution from that point on will fail\n   *    and tasks that completed successfully will not be rolled back.\n   * - The context is updated after each successful task execution.\n   *\n   * @returns A promise that resolves to the completed context object after all tasks have been executed.\n   *          The returned context includes the results of all tasks, with each task's result\n   *          stored under its task ID.\n   * @throws {Error} If any task in the graph fails and is not handled by its error handler.\n   */\n  run(): Promise<Required<TContext>>;\n}\n"],"mappings":";;;;;;;;;;;;;;;;AAAA;AAAA;","names":[]}