{"version":3,"sources":["../src/clujo.types.ts"],"sourcesContent":["import type { CronOptions } from \"croner\";\nimport type Redis from \"ioredis\";\nimport type { LockOptions, Mutex } from \"redis-semaphore\";\nimport type { ITask, RetryPolicy, TaskMap } from \"./task-graph.types\";\n\nexport interface IClujoStart {\n  /**\n   * Sets the schedule for the Clujo using a cron pattern.\n   * @param {string} pattern - The cron pattern to define the schedule.\n   * @param {CronOptions} [options] - Optional configuration for the cron job.\n   * @returns {IClujoBuilder<void, undefined>} A builder instance for further configuration.\n   */\n  // biome-ignore lint/complexity/noBannedTypes: valid use case here\n  setSchedule(pattern: string, options?: CronOptions): IClujoBuilder<void, {}>;\n}\n\nexport interface IClujoBuilder<TDependencies, TContext extends object> {\n  /**\n   * Builds the Clujo instance with the configured settings.\n   * Once a Clujo is created, tasks can be added to it, and it can be started.\n   * @returns {IClujo<TDependencies, TContext>} The built Clujo instance.\n   */\n  // biome-ignore lint/complexity/noBannedTypes: valid use case here\n  build(): IClujo<TDependencies, TContext, {}>;\n  /**\n   * Configures the Clujo to run immediately upon startup as well as on the schedule.\n   * @returns {IClujoBuilder<TDependencies, TContext>} The builder instance for method chaining.\n   */\n  runOnStartup(): IClujoBuilder<TDependencies, TContext>;\n  /**\n   * Sets the initial context object for the Clujo. A context is a value store in Clujo that is passed between tasks.\n   * A task adds its result to the context under the key of its task ID. In the event the task has no return, the value is undefined.\n   *\n   * @remarks\n   *   - The context can be an object or a (sync or async) function that returns an object.\n   *   - When no context is set, the context will be an empty object for the first task.\n   *   - When a context is set, it will always be set to the initial value before running the tasks.\n   *   - If some task `i` depends on tasks `j_1, j_2, ..., j_n`, the context passed to task `i` will be guaranteed to include the results of tasks `j_1, j_2, ..., j_n`.\n   *   - If a task has no dependencies, it has guaranteed access only to the initial context.\n   * @template TNewContext The type of the new context.\n   * @param {TNewContext | (() => TNewContext | Promise<TNewContext>)} valueOrFactory - The context value or a factory function that returns the context.\n   * @returns {IClujoBuilder<TDependencies, TNewContext>} The builder instance with the new context type.\n   */\n  setInitialContext<TNewContext>(\n    valueOrFactory: TNewContext | (() => TNewContext | Promise<TNewContext>),\n  ): IClujoBuilder<TDependencies, { initial: TNewContext }>;\n  /**\n   * Sets the dependencies for the Clujo.\n   * @template TNewDependencies The type of the new dependencies, which must be an object.\n   * @param {TNewDependencies} deps - The dependencies object to be used by the Clujo. All tasks will be able to access these dependencies.\n   * @returns {IClujoBuilder<TNewDependencies, TContext>} The builder instance with the new dependencies type.\n   */\n  setDependencies<TNewDependencies extends object>(deps: TNewDependencies): IClujoBuilder<TNewDependencies, TContext>;\n  /**\n   * Sets the retry policy for the Clujo.\n   *\n   * @remarks\n   *  - The retry policy is applied to all tasks in the Clujo.\n   *  - A task can override the Clujo's retry policy by providing its own retry policy.\n   *\n   * @param {RetryPolicy} policy - The retry policy to be applied to the Clujo.\n   * @param {number} [policy.maxRetries] - The maximum number of retries to attempt.\n   * @param {number} [policy.retryDelayMs] - The delay in milliseconds between retries.\n   * @returns {IClujoBuilder<TDependencies, TContext>} The builder instance for method chaining.\n   */\n  setRetryPolicy(policy: RetryPolicy): IClujoBuilder<TDependencies, TContext>;\n}\n\nexport interface IClujo<TDependencies, TContext, TTaskMap extends TaskMap<TDependencies, TContext>> {\n  /** The unique identifier for the Clujo instance. */\n  readonly id: string;\n  /**\n   * Adds a task to the Clujo's execution sequence.\n   *\n   * @remarks\n   * - case: N tasks each with no dependencies -> all tasks run concurrently\n   * - case: N tasks where task i depends on task i-1, i=1,...,N -> all tasks run sequentially\n   * - case: 1 <= i != j <= N. N tasks where task i depends on task j. N\\{i} tasks run concurrently, task i runs after task j\n   * - case: Task i depends on task j, task j depends on task i -> error\n   *\n   * @template TNewContext The type of the new context returned by the task.\n   * @param {TaskOptions<TDependencies, TContext, TNewContext>} options - The task configuration.\n   * @param {string} options.taskId - The unique identifier for the task.\n   * @param {TExecute<TDependencies, TContext, TNewContext>} options.execute - The task execution function.\n   * @param {TErrorHandler<TDependencies, TContext>} [options.errorHandler] (optional) - The error handler function. Defaults to logging the error.\n   * @param {RetryPolicy} [options.retryPolicy] (optional) - The retry policy for the task. Defaults to the Clujo's retry policy.\n   * @param {Array<keyof TTaskMap>} [options.dependencies] (optional) - The task IDs that this task depends on. If not provided, the task will run with no dependencies.\n   * @returns {IClujo<TDependencies, TNewContext>} A new IClujo instance with the updated context type.\n   * @throws {Error} If the Clujo is already running.\n   */\n  addTask<TTaskId extends string, TNewContext>({\n    taskId,\n    execute,\n    errorHandler,\n    retryPolicy,\n    dependencies,\n  }: {\n    taskId: TTaskId;\n    execute: TExecute<TDependencies, TContext, TNewContext>;\n    errorHandler?: TErrorHandler<TDependencies, TContext>;\n    retryPolicy?: RetryPolicy;\n    dependencies?: Array<keyof TTaskMap>;\n  }): IClujo<\n    TDependencies,\n    TContext &\n      Partial<{\n        [K in TTaskId]: TNewContext extends void ? undefined : TNewContext;\n      }>,\n    TTaskMap & {\n      [K in TTaskId]: ITask<\n        TDependencies,\n        TNewContext,\n        TContext &\n          Partial<{\n            [K in TTaskId]: TNewContext extends void ? undefined : TNewContext;\n          }>\n      >;\n    }\n  >;\n  /**\n   * Starts the Clujo execution.\n   *\n   * @remarks\n   * - Initializes the Clujo and begins its scheduled execution.\n   * - If Redis is provided, uses distributed locking to ensure only one instance of a clujo with the same id runs at a time.\n   * - If configured to run on startup, triggers immediate execution.\n   * - Can only be called once per Clujo instance.\n   *\n   * @param {StartOptions} [options] - Optional configuration for starting the Clujo.\n   * @param {Redis} options.redis - Redis instance for distributed locking.\n   * @param {LockOptions} [options.options] - Optional lock configuration.\n   * @returns {IClujo<TDependencies, TContext>} The started Clujo instance.\n   * @throws {Error} If the Clujo has already been started.\n   */\n  start(options?: StartOptions<TContext>): IClujo<TDependencies, TContext, TTaskMap>;\n  /**\n   * Stops the Clujo execution. If the Clujo is currently running, it will complete the current task before stopping.\n   *\n   * @returns {Promise<void>} A promise that resolves when the Clujo has been stopped.\n   * @throws {Error} If the Clujo has not been started.\n   */\n  stop(): Promise<void>;\n  /**\n   * Triggers an immediate execution of the Clujo tasks.\n   *\n   * @remarks\n   * - Initiates an immediate run of the Clujo's task sequence outside of its scheduled execution.\n   * - Can be used to manually trigger the Clujo at any time after it has been started.\n   * - If the Clujo is currently executing, the behavior of this depends on the whether Redis is used for locking and the `protect` cron option is set.\n   *\n   * @returns {Promise<void>} A promise that resolves when the triggered execution is complete.\n   * @throws {Error} If the Clujo has not been started.\n   */\n  trigger(): Promise<void>;\n}\n\nexport type TExecute<TDependencies, TContext, TReturn> = ({\n  deps,\n  ctx,\n}: {\n  deps: TDependencies;\n  ctx: TContext;\n}) => Promise<TReturn> | TReturn;\n\nexport type TErrorHandler<TDependencies, TContext> = (\n  err: Error,\n  {\n    deps,\n    ctx,\n  }: {\n    deps: TDependencies;\n    ctx: TContext;\n  },\n) => Promise<void> | void;\n\nexport interface StartOptions<TContext> {\n  completionHandler?: (ctx: Required<TContext>) => Promise<void> | void;\n  redis?: Redis;\n  options?: LockOptions;\n}\n\nexport interface ILock extends AsyncDisposable {\n  mutex: Mutex;\n}\n"],"mappings":";;;;;;;;;;;;;;;;AAAA;AAAA;","names":[]}