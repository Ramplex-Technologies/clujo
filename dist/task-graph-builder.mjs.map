{"version":3,"sources":["../src/task-graph-builder.ts","../src/context.ts","../src/task-graph.ts"],"sourcesContent":["import { promisify } from \"node:util\";\nimport { TaskGraph } from \"./task-graph\";\nimport type {\n  ITask,\n  ITaskGraph,\n  ITaskGraphBuilder,\n  ITaskGraphBuilderHelper,\n  RetryPolicy,\n  TaskMap,\n  TaskOptions,\n  TaskStatus,\n} from \"./task-graph.types\";\n\nconst sleep = promisify(setTimeout);\n\nclass Task<TCommonInput, TContextInput, TReturn> implements ITask<TCommonInput, TContextInput, TReturn> {\n  private readonly _dependencies: string[] = [];\n  private _retryPolicy: RetryPolicy = { maxRetries: 0, retryDelayMs: 0 };\n  private _status: TaskStatus = \"pending\";\n\n  constructor(\n    private readonly options: TaskOptions<string, TCommonInput, TContextInput, TReturn, string | number | symbol>,\n  ) {\n    if (options.retryPolicy) this._retryPolicy = options.retryPolicy;\n  }\n\n  public get id() {\n    return this.options.id;\n  }\n\n  public get status() {\n    return this._status;\n  }\n\n  public get dependencies() {\n    return this._dependencies;\n  }\n\n  public addDependency(taskId: string) {\n    this._dependencies.push(taskId);\n  }\n\n  public async run(deps: TCommonInput, ctx: TContextInput): Promise<TReturn> {\n    // we retry maxRetries times on top of the initial attempt\n    for (let attempt = 0; attempt < this._retryPolicy.maxRetries + 1; attempt++) {\n      try {\n        const result = await this.options.execute({ deps, ctx });\n        this._status = \"completed\";\n        return result;\n      } catch (err) {\n        if (attempt === this._retryPolicy.maxRetries) {\n          console.error(`Task failed after ${attempt + 1} attempts: ${err}`);\n          const error = err instanceof Error ? err : new Error(`Non error throw: ${String(err)}`);\n          try {\n            if (this.options.errorHandler) await this.options.errorHandler(error, { deps, ctx });\n            else console.error(`Error in task ${this.options.id}: ${err}`);\n          } catch (error) {\n            console.error(`Error in task error handler for ${this.options.id}: ${error}`);\n          }\n          this._status = \"failed\";\n          throw error;\n        }\n        console.error(`Task failed, retrying (attempt ${attempt + 1}/${this._retryPolicy.maxRetries}): ${err}`);\n        await sleep(this._retryPolicy.retryDelayMs);\n      }\n    }\n\n    // This line should never be reached due to the for loop condition,\n    // but TypeScript requires a return statement here\n    throw new Error(\"Unexpected end of run method\");\n  }\n}\n\nexport class TaskGraphBuilder<TDependencies, TContext extends object>\n  implements ITaskGraphBuilder<TDependencies, TContext>\n{\n  private contextValueOrFactory: unknown = undefined;\n  private dependencies!: TDependencies;\n\n  finalizeSetup() {\n    // biome-ignore lint/complexity/noBannedTypes: <explanation>\n    return new TaskGraphBuilderHelper<TDependencies, TContext, {}>(\n      this.dependencies,\n      this.contextValueOrFactory as undefined | TContext | (() => TContext | Promise<TContext>),\n    );\n  }\n\n  setDependencies<TNewDependencies>(value?: undefined | TNewDependencies) {\n    this.dependencies = value as unknown as TDependencies;\n    return this as unknown as ITaskGraphBuilder<TNewDependencies, TContext>;\n  }\n\n  setInitialContext<TNewContext extends object>(\n    valueOrFactory?: undefined | TNewContext | (() => TNewContext | Promise<TNewContext>),\n  ) {\n    this.contextValueOrFactory = valueOrFactory;\n    return this as unknown as ITaskGraphBuilder<TDependencies, TNewContext>;\n  }\n}\n\nexport class TaskGraphBuilderHelper<\n  TDependencies,\n  TContext extends object,\n  TTaskMap extends TaskMap<TDependencies, TContext>,\n> implements ITaskGraphBuilderHelper<TDependencies, TContext, TTaskMap>\n{\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  private readonly tasks: Map<string, ITask<TDependencies, TContext, any>> = new Map();\n  private readonly order: string[] = [];\n\n  constructor(\n    private readonly dependencies: TDependencies,\n    private readonly contextValueOrFactory: undefined | TContext | (() => TContext | Promise<TContext>),\n  ) {}\n\n  public get size() {\n    return this.tasks.size;\n  }\n\n  build(): ITaskGraph<TContext> {\n    this.topologicalSort();\n    return new TaskGraph(this.dependencies, this.contextValueOrFactory, this.tasks, this.order);\n  }\n\n  addTask<TTaskId extends string, TReturn>(\n    options: TaskOptions<TTaskId, TDependencies, TContext, TReturn, keyof TTaskMap>,\n  ): ITaskGraphBuilderHelper<\n    TDependencies,\n    TContext & Partial<{ [K in TTaskId]: TReturn }>,\n    TTaskMap & { [K in TTaskId]: ITask<TDependencies, TContext & Partial<{ [K in TTaskId]: TReturn }>, TReturn> }\n  > {\n    const taskId = options.id;\n    if (this.tasks.has(taskId)) {\n      throw new Error(`Task with id ${taskId} already exists`);\n    }\n    const task = new Task(options);\n    this.tasks.set(taskId, task);\n\n    for (const depId of options.dependencies ?? []) {\n      if (typeof depId !== \"string\") throw new Error(\"Dependency ID must be a string\");\n      const dependentTask = this.tasks.get(depId);\n      if (!dependentTask) throw new Error(`Dependency ${depId} not found for task ${taskId}`);\n      task.addDependency(depId);\n    }\n\n    return this as unknown as ITaskGraphBuilderHelper<\n      TDependencies,\n      TContext & Partial<{ [K in TTaskId]: TReturn }>,\n      TTaskMap & { [K in TTaskId]: ITask<TDependencies, TContext & Partial<{ [K in TTaskId]: TReturn }>, TReturn> }\n    >;\n  }\n\n  private topologicalSort() {\n    const visited = new Set<string>();\n    const temp = new Set<string>();\n\n    const visit = (taskId: string) => {\n      if (temp.has(taskId)) {\n        throw new Error(`Circular dependency detected involving task ${taskId}`);\n      }\n      if (!visited.has(taskId)) {\n        temp.add(taskId);\n        const task = this.tasks.get(taskId);\n        if (!task) throw new Error(`Task ${taskId} not found`);\n\n        for (const depId of task.dependencies) {\n          visit(depId);\n        }\n\n        temp.delete(taskId);\n        visited.add(taskId);\n        this.order.push(taskId);\n      }\n    };\n\n    for (const taskId of this.tasks.keys()) {\n      if (!visited.has(taskId)) {\n        visit(taskId);\n      }\n    }\n  }\n}\n","/**\n * Used to allow for the sharing of state between tasks.\n */\nexport class Context<T extends object> {\n  private object!: { initial: object | undefined } & T;\n  private updateQueue: Promise<void>;\n\n  constructor(initialObject?: object) {\n    this.reset(initialObject);\n    this.updateQueue = Promise.resolve();\n  }\n\n  /**\n   * Gets the current state of the managed object.\n   */\n  public get value(): { initial: object | undefined } & T {\n    return this.object;\n  }\n\n  /**\n   * Resets the context to its initial state or a new initial object.\n   */\n  public reset(initialObject?: object): void {\n    if (initialObject) {\n      this.object = { initial: { ...initialObject } } as {\n        initial: object | undefined;\n      } & T;\n    } else {\n      this.object = { initial: undefined } as {\n        initial: object | undefined;\n      } & T;\n    }\n  }\n\n  /**\n   * Asynchronously updates the context with new values. Ensures that updates are applied in the order they are called.\n   */\n  public update<NewValue extends object>(updateValue: NewValue): Promise<void> {\n    this.updateQueue = this.updateQueue.then(() => {\n      // overrides won't happen with how this is used since\n      // the initial context is under the key \"initial\"\n      // and all task results are under the unique id of that task\n      this.object = { ...this.object, ...updateValue };\n      return Promise.resolve();\n    });\n    return this.updateQueue;\n  }\n}\n","import { Context } from \"./context\";\nimport type { ITask, ITaskGraph } from \"./task-graph.types\";\n\nexport class TaskGraph<TDependencies, TContext extends object> implements ITaskGraph<TContext> {\n  private readonly context: Context<TContext> = new Context<TContext>();\n\n  constructor(\n    private readonly taskDependencies: TDependencies,\n    private readonly contextValueOrFactory: undefined | TContext | (() => TContext | Promise<TContext>),\n    private readonly tasks: Map<string, ITask<TDependencies, TContext, unknown>>,\n    private readonly order: string[],\n  ) {}\n\n  run = async (): Promise<Required<TContext>> => {\n    if (this.order.length === 0) throw new Error(\"No tasks to run. Did you forget to call topologicalSort?\");\n    let value: TContext | undefined;\n    if (this.contextValueOrFactory) {\n      value =\n        typeof this.contextValueOrFactory === \"function\"\n          ? await this.contextValueOrFactory()\n          : this.contextValueOrFactory;\n    }\n    this.context.reset(value);\n\n    const completed = new Set<string>();\n    const running = new Map<string, Promise<void>>();\n    const readyTasks = new Set<string>(\n      this.order.filter((taskId) => this.tasks.get(taskId)?.dependencies.length === 0),\n    );\n\n    const runTask = async (taskId: string) => {\n      const task = this.tasks.get(taskId);\n      if (!task) throw new Error(`Task ${taskId} not found`);\n\n      try {\n        const result = await task.run(this.taskDependencies, this.context.value);\n        await this.context.update({ [taskId]: result });\n        completed.add(taskId);\n      } catch {\n        // completed in the sense that we won't try to run it again\n        completed.add(taskId);\n      } finally {\n        running.delete(taskId);\n\n        // Check if any dependent tasks are now ready to run\n        for (const [id, t] of this.tasks) {\n          if (!completed.has(id) && !running.has(id)) {\n            const canRun = t.dependencies.every((depId) => {\n              const depTask = this.tasks.get(depId);\n              return depTask && completed.has(depId) && depTask.status === \"completed\";\n            });\n            if (canRun) readyTasks.add(id);\n          }\n        }\n      }\n    };\n\n    while (completed.size < this.tasks.size) {\n      // Start all ready tasks\n      for (const taskId of readyTasks) {\n        readyTasks.delete(taskId);\n        const promise = runTask(taskId);\n        running.set(taskId, promise);\n      }\n\n      // Wait for at least one task to complete\n      if (running.size > 0) {\n        await Promise.race(running.values());\n      } else {\n        // no tasks are running and we have not completed all tasks\n        // happens when tasks could not run due to failed dependencies\n        break;\n      }\n    }\n\n    return this.context.value as Required<TContext>;\n  };\n}\n"],"mappings":"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","names":["error"]}