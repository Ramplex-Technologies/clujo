{"version":3,"sources":["../src/clujo.ts","../src/cron.ts","../src/scheduler.ts","../src/task-graph.ts","../src/context.ts"],"sourcesContent":["/* --------------------------------------------------------------------------\n\n  croner - MIT License - Hexagon <hexagon@56k.guru>\n  ioredis - MIT License - Zihua Li\n  redis-semaphore - MIT License - Alexander Mochalin\n\n  ---------------------------------------------------------------------------\n\n  MIT License\n\n  Copyright (c) 2024 Rami Pellumbi\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n-----------------------------------------------------------------------------*/\n\nimport type { CronOptions } from \"croner\";\nimport type { Redis } from \"ioredis\";\nimport { type LockOptions, Mutex } from \"redis-semaphore\";\nimport { Cron } from \"./cron\";\nimport type { TaskGraphRunner } from \"./task-graph\";\n\nexport class Clujo<\n  TTaskDependencies extends Record<string, unknown>,\n  TTaskContext extends Record<string, unknown> & {\n    initial: unknown;\n  },\n> {\n  public readonly id: string;\n\n  private readonly _cron: Cron;\n  private readonly _taskGraphRunner: TaskGraphRunner<TTaskDependencies, TTaskContext>;\n\n  private _hasStarted = false;\n  private _runImmediately = false;\n\n  constructor({\n    id,\n    taskGraphRunner,\n    cron,\n  }: {\n    id: string;\n    taskGraphRunner: TaskGraphRunner<TTaskDependencies, TTaskContext>;\n    cron: { pattern: string; options?: CronOptions };\n  }) {\n    if (!id) throw new Error(\"Clujo ID is required.\");\n    if (!taskGraphRunner) throw new Error(\"taskGraphRunner is required\");\n    if (!cron.pattern) throw new Error(\"cron.pattern is required\");\n    this.id = id;\n    this._taskGraphRunner = taskGraphRunner;\n    // TODO: validate pattern\n    this._cron = new Cron(cron.pattern, cron.options);\n  }\n\n  public runOnStartup() {\n    if (this._hasStarted) throw new Error(\"Cannot run on startup after starting a Clujo.\");\n    this._runImmediately = true;\n    return this;\n  }\n\n  public start(\n    {\n      redis,\n      onTaskCompletion,\n    }: {\n      redis?: { client: Redis; lockOptions?: LockOptions };\n      onTaskCompletion?: (ctx: TTaskContext) => void | Promise<void>;\n    } = {\n      redis: undefined,\n      onTaskCompletion: undefined,\n    },\n  ) {\n    if (this._hasStarted) throw new Error(\"Cannot start a Clujo that has already started.\");\n    const executeTasksAndCompletionHandler = async () => {\n      const finalContext = await this._taskGraphRunner.run();\n      if (onTaskCompletion) await onTaskCompletion(finalContext);\n    };\n\n    const handler = async () => {\n      try {\n        if (!redis) await executeTasksAndCompletionHandler();\n        else {\n          await using lock = await this._tryAcquire(redis.client, redis.lockOptions);\n          if (lock) await executeTasksAndCompletionHandler();\n        }\n      } catch (error) {\n        console.error(`Clujo ${this.id} failed: ${error}`);\n      }\n    };\n    this._cron.start(handler);\n    this._hasStarted = true;\n    // we use the cron trigger here so that prevent overlapping is active by default\n    // i.e., if no lock is used, and the trigger is executing, and the schedule time is reached, the scheduled execution will be skipped\n    if (this._runImmediately) this._cron.trigger();\n    return this;\n  }\n\n  public async stop(timeout = 5000): Promise<void> {\n    if (!this._hasStarted) throw new Error(\"Cannot stop a Clujo that has not started.\");\n    await this._cron.stop(timeout);\n  }\n\n  public async trigger(): Promise<TTaskContext> {\n    // we do not trigger via the cron here so that we can make use of the result of the task graph\n    return await this._taskGraphRunner.run();\n  }\n\n  private async _tryAcquire(redis: Redis, lockOptions: LockOptions | undefined): Promise<ILock | null> {\n    const mutex = new Mutex(redis, this.id, lockOptions);\n    const lock = await mutex.tryAcquire();\n    if (!lock) return null;\n    return {\n      mutex,\n      [Symbol.asyncDispose]: async () => {\n        try {\n          await mutex.release();\n        } catch (error) {\n          console.error(`Error releasing lock for Clujo ${this.id}: ${error}`);\n        }\n      },\n    };\n  }\n}\n\ninterface ILock extends AsyncDisposable {\n  mutex: Mutex;\n}\n","/* --------------------------------------------------------------------------\n\n  croner - MIT License - Hexagon <hexagon@56k.guru>\n\n  ---------------------------------------------------------------------------\n\n  MIT License\n\n  Copyright (c) 2024 Rami Pellumbi\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n-----------------------------------------------------------------------------*/\n\nimport { Cron as Croner, type CronOptions } from \"croner\";\n\nexport class Cron {\n  private job: Croner | null = null;\n\n  constructor(\n    private readonly cronExpression: string,\n    private readonly cronOptions?: CronOptions,\n  ) {}\n\n  /**\n   * Starts the cron job with the specified handler.\n   *\n   * @param handler A function to be executed when the cron job triggers.\n   * @throws {Error} If attempting to start a job that has already been started.\n   */\n  public start(handler: () => Promise<void> | void): void {\n    if (this.job) throw new Error(\"Attempting to start an already started job\");\n    this.job = new Croner(this.cronExpression, this.cronOptions, handler);\n  }\n\n  /**\n   * Stops the cron job. If the job is currently running, it will wait for the job to finish before stopping it.\n   * This can be safely invoked even if the job hasn't been started.\n   *\n   * @param timeout The maximum time (in ms) to wait for the job to finish before stopping it forcefully.\n   * @returns A promise that resolves when the job has been stopped\n   */\n  public stop(timeout: number): Promise<void> {\n    if (!this.job) return Promise.resolve();\n    return new Promise<void>((resolve) => {\n      const startTime = Date.now();\n      const checkAndStop = () => {\n        if (!this.job) {\n          resolve(); // resolve if job has cleared\n          return;\n        }\n\n        if (this.job.isBusy()) {\n          if (Date.now() - startTime > timeout) {\n            this.job.stop();\n            this.job = null;\n            resolve();\n            return;\n          }\n          setTimeout(checkAndStop, 100);\n        } else {\n          this.job.stop();\n          this.job = null;\n          resolve();\n          return;\n        }\n      };\n\n      checkAndStop();\n    });\n  }\n\n  /**\n   * Triggers the cron job to run immediately. A triggered execution will prevent the job from running at its scheduled time\n   * unless `preventOverlap` is set to `false` in the cron options.\n   *\n   * @throws {Error} If attempting to trigger a job that is not running.\n   */\n  public async trigger(): Promise<void> {\n    if (!this.job) throw new Error(\"Attempting to trigger a job that is not running\");\n    await this.job.trigger();\n  }\n}\n","/* --------------------------------------------------------------------------\n\n  croner - MIT License - Hexagon <hexagon@56k.guru>\n  ioredis - MIT License - Zihua Li\n\n  ---------------------------------------------------------------------------\n\n  MIT License\n\n  Copyright (c) 2024 Rami Pellumbi\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n-----------------------------------------------------------------------------*/\n\nimport type Redis from \"ioredis\";\nimport type { Clujo } from \"./clujo\";\n\n/**\n * Scheduler class for managing and running Clujo jobs.\n * This class allows adding, starting, and stopping multiple Clujo jobs in a centralized manner.\n */\nexport class Scheduler {\n  // biome-ignore lint/suspicious/noExplicitAny: handle any combination of clujo's\n  private readonly jobs: { job: Clujo<any, any>; completionHandler?: (ctx: any) => Promise<void> | void }[] = [];\n\n  /**\n   * Adds a Clujo job to the scheduler.\n   * @param input - Object containing the job and optional completion handler.\n   * @param input.job - The Clujo job to be added.\n   * @param input.completionHandler - Optional function to invoke after the job completes.\n   */\n  public addJob<\n    TDependencies extends Record<string, unknown>,\n    TContext extends Record<string, unknown> & { initial: unknown },\n  >(input: {\n    job: Clujo<TDependencies, TContext>;\n    completionHandler?: (ctx: Required<TContext>) => Promise<void> | void;\n  }) {\n    this.jobs.push(input);\n  }\n\n  /**\n   * Starts all added jobs in the scheduler.\n   * @param redis - Optional Redis instance to be passed to the jobs. If provided, enables distributed locking.\n   */\n  public start(redis?: Redis) {\n    for (const { job, completionHandler } of this.jobs) {\n      const options: Record<string, unknown> = {};\n      if (redis) {\n        options.redis = { client: redis };\n      }\n      if (completionHandler) {\n        options.onTaskCompletion = completionHandler;\n      }\n      job.start(options);\n    }\n  }\n  /**\n   * Stops all running jobs in the scheduler.\n   * @param timeout - The maximum time (in milliseconds) to wait for jobs to stop.\n   * @returns A promise that resolves when all jobs have stopped or the timeout is reached.\n   */\n  public async stop(timeout: number) {\n    await Promise.all(this.jobs.map(({ job }) => job.stop(timeout)));\n  }\n}\n","/* --------------------------------------------------------------------------\n\n  MIT License\n\n  Copyright (c) 2024 Rami Pellumbi\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n-----------------------------------------------------------------------------*/\n\nimport { promisify } from \"node:util\";\nimport { Context } from \"./context\";\n\nconst sleep = promisify(setTimeout);\n\nexport class TaskGraph<\n  TTaskDependencies extends Record<string, unknown> = Record<string, never>,\n  TTaskContext extends Record<string, unknown> & { initial: unknown } = { initial: unknown },\n> {\n  // start with an undefined context value (placed under key initial)\n  private _contextValueOrFactory: unknown = undefined;\n  // start with an empty dependencies object\n  private _dependencies: unknown = Object.create(null);\n\n  /**\n   * Finalizes the setup and returns an instance of `TaskGraphBuilder`.\n   * Once invoked, the initial context and dependencies are no longer mutable.\n   *\n   * @returns A new instance of `TaskGraphBuilder` with the current state.\n   */\n  public finalize() {\n    // return a new instance of TaskGraph with the current state\n    return new TaskGraphBuilder<TTaskDependencies, TTaskContext>(\n      this._dependencies as TTaskDependencies,\n      this._contextValueOrFactory as undefined | TTaskContext | (() => TTaskContext | Promise<TTaskContext>),\n    );\n  }\n\n  /**\n   * Sets the initial context for the task graph.\n   * This context will be passed to the first task(s) in the graph under the `initial` key.\n   * Multiple invocation of this method will override the previous context.\n   *\n   * @template TNewContext The type of the new context.\n   * @param valueOrFactory - The initial context value or a factory function to create it.\n   *                         If a function is provided, it can be synchronous or asynchronous.\n   * @returns A TaskGraph instance with the new context type.\n   */\n  public setContext<TNewContext>(valueOrFactory: TNewContext | (() => TNewContext | Promise<TNewContext>)) {\n    // set the context value to the provided value or factory\n    this._contextValueOrFactory = valueOrFactory;\n    // return the builder with the new context type\n    return this as unknown as TaskGraph<TTaskDependencies, { initial: TNewContext }>;\n  }\n\n  /**\n   * Sets the dependencies for the task graph. These dependencies will be available to all tasks in the graph.\n   * Multiple invocation of this method will override the previous dependencies.\n   *\n   * @template TNewDependencies The type of the new dependencies, which must be an object.\n   * @param value - The dependencies object to be used across all tasks in the graph.\n   * @returns A TaskGraph instance with the new dependencies type.\n   */\n  public setDependencies<TNewDependencies extends Record<string, unknown>>(value: TNewDependencies) {\n    if (typeof value !== \"object\" || value === null) throw new Error(\"Initial dependencies must be an object\");\n    // set the dependencies object to the provided value\n    this._dependencies = value as unknown as TTaskDependencies;\n    // return the builder with the new dependencies type\n    return this as unknown as TaskGraph<TNewDependencies, TTaskContext>;\n  }\n}\n\nclass TaskGraphBuilder<\n  TTaskDependencies extends Record<string, unknown>,\n  TTaskContext extends Record<string, unknown> & { initial: unknown },\n  TAllDependencyIds extends string = string & keyof Omit<TTaskContext, \"initial\">,\n> {\n  private readonly _tasks = new Map<string, Task<TTaskDependencies, TTaskContext, unknown, TAllDependencyIds>>();\n  private readonly _topologicalOrder: string[] = [];\n\n  constructor(\n    private _dependencies: TTaskDependencies,\n    private _contextValueOrFactory: undefined | TTaskContext | (() => TTaskContext | Promise<TTaskContext>),\n  ) {}\n\n  /**\n   * Adds a new task to the graph.\n   *\n   * @template TTaskId The ID of the task, which must be unique.\n   * @template TTaskDependencyIds The IDs of the task's dependencies.\n   * @template TTaskReturn The return type of the task.\n   * @param options The configuration options for the task:\n   * @param options.id A unique identifier for the task.\n   * @param options.execute A function that performs the task's operation. It receives an object with `deps` (dependencies) and `ctx` (context) properties.\n   * @param options.dependencies An optional array of task IDs that this task depends on. If not provided, the task will be executed immediately on start.\n   * @param options.retryPolicy An optional retry policy for the task, specifying maxRetries and retryDelayMs. Defaults to no retries.\n   * @param options.errorHandler An optional function to handle errors that occur during task execution. Defaults to `console.error`.\n   *\n   * @returns A new instance of `TaskGraphBuilder` with the new task added for chaining.\n   *\n   * @throws {Error} If a task with the same ID already exists.\n   * @throws {Error} If a specified dependency task has not been added to the graph yet.\n   *\n   * @returns A new instance of `TaskGraphBuilder` with the new task added for chaining.\n   */\n  public addTask<TTaskId extends string, TTaskDependencyIds extends TAllDependencyIds, TTaskReturn>(\n    options: TaskOptions<TTaskId, TTaskDependencies, TTaskContext, TTaskReturn, TTaskDependencyIds>,\n  ) {\n    const taskId = options.id;\n    if (this._tasks.has(taskId)) throw new Error(`Task with id ${taskId} already exists`);\n    const task = new Task<TTaskDependencies, TTaskContext, TTaskReturn, TAllDependencyIds>(options);\n    this._tasks.set(taskId, task);\n\n    for (const depId of options.dependencies ?? []) {\n      if (typeof depId !== \"string\") throw new Error(\"Dependency ID must be a string\");\n      const dependentTask = this._tasks.get(depId);\n      if (!dependentTask) throw new Error(`Dependency ${depId} not found for task ${taskId}`);\n      task.addDependency(depId);\n    }\n\n    return this as unknown as TaskGraphBuilder<\n      TTaskDependencies,\n      TTaskContext &\n        Partial<{\n          [K in TTaskId]: TTaskReturn;\n        }>,\n      TAllDependencyIds | TTaskId\n    >;\n  }\n\n  /**\n   * Builds and returns a TaskGraphRunner instance.\n   * This method finalizes the task graph and prepares it for execution by topologically sorting the tasks.\n   *\n   * @returns A new `TaskGraphRunner` instance ready to execute the task graph.\n   *\n   * @throws {Error} If no tasks have been added to the graph.\n   */\n  public build() {\n    if (!this.size) throw new Error(\"Unable to build TaskGraphRunner. No tasks added to the graph\");\n    this._topologicalSort();\n    return new TaskGraphRunner(this._dependencies, this._contextValueOrFactory, this._topologicalOrder, this._tasks);\n  }\n\n  /**\n   * Returns the number of tasks in the graph.\n   */\n  public get size() {\n    return this._tasks.size;\n  }\n\n  /**\n   * Topologically sorts the tasks in the graph, placing the sorted order in the `_topologicalOrder` array.\n   */\n  private _topologicalSort() {\n    const visited = new Set<string>();\n    const temp = new Set<string>();\n\n    const visit = (taskId: string) => {\n      if (temp.has(taskId)) throw new Error(`Circular dependency detected involving task ${taskId}`);\n      if (!visited.has(taskId)) {\n        temp.add(taskId);\n        const task = this._tasks.get(taskId);\n        if (!task) throw new Error(`Task ${taskId} not found`);\n        for (const depId of task.dependencies) visit(depId);\n        temp.delete(taskId);\n        visited.add(taskId);\n        this._topologicalOrder.push(taskId);\n      }\n    };\n\n    for (const taskId of this._tasks.keys()) if (!visited.has(taskId)) visit(taskId);\n    visited.clear();\n    temp.clear();\n  }\n}\n\nexport class TaskGraphRunner<\n  TTaskDependencies extends Record<string, unknown>,\n  TTaskContext extends Record<string, unknown> & { initial: unknown },\n> {\n  private readonly context = new Context<TTaskContext[\"initial\"], TTaskContext>();\n\n  constructor(\n    private _dependencies: TTaskDependencies,\n    private _contextValueOrFactory: undefined | TTaskContext | (() => TTaskContext | Promise<TTaskContext>),\n    private readonly _topologicalOrder: string[],\n    private readonly _tasks: Map<string, Task<TTaskDependencies, TTaskContext, unknown, string>>,\n  ) {}\n\n  /**\n   * Runs the tasks in the graph in topological order.\n   * Tasks are run concurrently when possible.\n   * In the event a task fails, other independent tasks will continue to run.\n   *\n   * @returns A promise that resolves to the completed context object when all tasks have completed.\n   */\n  async run(): Promise<TTaskContext> {\n    if (this._topologicalOrder.length === 0)\n      throw new Error(\"No tasks to run. Did you forget to call topologicalSort?\");\n\n    let value: TTaskContext[\"initial\"] | undefined;\n    if (this._contextValueOrFactory) {\n      value =\n        typeof this._contextValueOrFactory === \"function\"\n          ? await (this._contextValueOrFactory as () => TTaskContext[\"initial\"] | Promise<TTaskContext[\"initial\"]>)()\n          : this._contextValueOrFactory;\n    }\n    this.context.reset(value);\n\n    const completed = new Set<string>();\n    const running = new Map<string, Promise<void>>();\n    const readyTasks = new Set<string>(\n      this._topologicalOrder.filter((taskId) => this._tasks.get(taskId)?.dependencies.length === 0),\n    );\n\n    const runTask = async (taskId: string) => {\n      const task = this._tasks.get(taskId);\n      if (!task) throw new Error(`Task ${taskId} not found`);\n\n      try {\n        const result = await task.run(this._dependencies, this.context.value);\n        await this.context.update({ [taskId]: result });\n        completed.add(taskId);\n      } catch {\n        // completed in the sense that we won't try to run it again\n        completed.add(taskId);\n      } finally {\n        running.delete(taskId);\n\n        // Check if any dependent tasks are now ready to run\n        for (const [id, t] of this._tasks) {\n          if (!completed.has(id) && !running.has(id)) {\n            const canRun = t.dependencies.every((depId) => {\n              const depTask = this._tasks.get(depId);\n              return depTask && completed.has(depId) && depTask.status === \"completed\";\n            });\n            if (canRun) readyTasks.add(id);\n          }\n        }\n      }\n    };\n\n    while (completed.size < this._tasks.size) {\n      // Start all ready tasks\n      for (const taskId of readyTasks) {\n        readyTasks.delete(taskId);\n        const promise = runTask(taskId);\n        running.set(taskId, promise);\n      }\n\n      // Wait for at least one task to complete\n      if (running.size > 0) {\n        await Promise.race(running.values());\n      } else {\n        // no tasks are running and we have not completed all tasks\n        // happens when tasks could not run due to failed dependencies\n        break;\n      }\n    }\n\n    return this.context.value;\n  }\n}\n\nclass Task<\n  TTaskDependencies extends Record<string, unknown>,\n  TTaskContext extends Record<string, unknown> & { initial: unknown },\n  TTaskReturn,\n  TPossibleTaskId,\n> {\n  private readonly _dependencies: TPossibleTaskId[] = [];\n\n  private _retryPolicy: RetryPolicy = { maxRetries: 0, retryDelayMs: 0 };\n  private _status: TaskStatus = \"pending\";\n\n  constructor(private readonly options: TaskOptions<string, TTaskDependencies, TTaskContext, TTaskReturn, string>) {\n    if (options.retryPolicy) this._retryPolicy = options.retryPolicy;\n  }\n\n  public addDependency(taskId: TPossibleTaskId) {\n    this._dependencies.push(taskId);\n  }\n\n  public get dependencies() {\n    return this._dependencies;\n  }\n\n  public get id() {\n    return this.options.id;\n  }\n\n  public async run(deps: TTaskDependencies, ctx: TTaskContext): Promise<TTaskReturn> {\n    // we retry maxRetries times on top of the initial attempt\n    for (let attempt = 0; attempt < this._retryPolicy.maxRetries + 1; attempt++) {\n      try {\n        this._status = \"running\";\n        const result = await this.options.execute({ deps, ctx });\n        this._status = \"completed\";\n        return result;\n      } catch (err) {\n        if (attempt === this._retryPolicy.maxRetries) {\n          console.error(`Task failed after ${attempt + 1} attempts: ${err}`);\n          const error = err instanceof Error ? err : new Error(`Non error throw: ${String(err)}`);\n          try {\n            if (this.options.errorHandler) await this.options.errorHandler(error, { deps, ctx });\n            else console.error(`Error in task ${this.options.id}: ${err}`);\n          } catch (error) {\n            console.error(`Error in task error handler for ${this.options.id}: ${error}`);\n          }\n          this._status = \"failed\";\n          throw error;\n        }\n        console.error(`Task failed, retrying (attempt ${attempt + 1}/${this._retryPolicy.maxRetries}): ${err}`);\n        await sleep(this._retryPolicy.retryDelayMs);\n      }\n    }\n\n    // This line should never be reached due to the for loop condition,\n    // but TypeScript requires a return statement here\n    throw new Error(\"Unexpected end of run method\");\n  }\n\n  public get status() {\n    return this._status;\n  }\n}\n\ntype RetryPolicy = {\n  maxRetries: number;\n  retryDelayMs: number;\n};\n\ntype TaskOptions<\n  TTaskId extends string,\n  TTaskDependencies extends Record<string, unknown>,\n  TTaskContext extends Record<string, unknown> & { initial: unknown },\n  TTaskReturn,\n  TPossibleTaskDependencyId extends string = never,\n  TInput = { deps: TTaskDependencies; ctx: TTaskContext },\n> = {\n  id: TTaskId;\n  dependencies?: TPossibleTaskDependencyId[];\n  retryPolicy?: RetryPolicy;\n  execute: (input: TInput) => Promise<TTaskReturn> | TTaskReturn;\n  errorHandler?: (err: Error, input: TInput) => Promise<void> | void;\n};\n\ntype TaskStatus = \"pending\" | \"completed\" | \"failed\" | \"running\";\n","/* --------------------------------------------------------------------------\n\n  MIT License\n\n  Copyright (c) 2024 Rami Pellumbi\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n-----------------------------------------------------------------------------*/\n\n/**\n * Used to allow for the sharing of state between tasks.\n */\nexport class Context<TInitial, TContext> {\n  private object!: { initial: TInitial | undefined } & TContext;\n  private updateQueue: Promise<void>;\n\n  constructor(initialValue?: TInitial) {\n    this.reset(initialValue);\n    this.updateQueue = Promise.resolve();\n  }\n\n  /**\n   * Gets the current state of the managed object.\n   */\n  public get value(): { initial: TInitial | undefined } & TContext {\n    return this.object;\n  }\n\n  /**\n   * Resets the context to its initial state or a new initial object.\n   */\n  public reset(initialValue: TInitial | undefined): void {\n    if (initialValue !== undefined && initialValue !== null) {\n      this.object = { initial: initialValue } as {\n        initial: TInitial;\n      } & TContext;\n    } else {\n      this.object = { initial: undefined } as {\n        initial: TInitial | undefined;\n      } & TContext;\n    }\n  }\n\n  /**\n   * Asynchronously updates the context with new values. Ensures that updates are applied in the order they are called.\n   */\n  public update<NewValue extends object>(updateValue: NewValue): Promise<void> {\n    this.updateQueue = this.updateQueue.then(() => {\n      // overrides won't happen with how this is used since\n      // the initial context is under the key \"initial\"\n      // and all task results are under the unique id of that task\n      this.object = { ...this.object, ...updateValue };\n      return Promise.resolve();\n    });\n    return this.updateQueue;\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA,SAA2B,aAAa;;;ACJxC,SAAS,QAAQ,cAAgC;AAE1C,IAAM,OAAN,MAAW;AAAA,EAGhB,YACmB,gBACA,aACjB;AAFiB;AACA;AAAA,EAChB;AAAA,EALK,MAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAatB,MAAM,SAA2C;AACtD,QAAI,KAAK,IAAK,OAAM,IAAI,MAAM,4CAA4C;AAC1E,SAAK,MAAM,IAAI,OAAO,KAAK,gBAAgB,KAAK,aAAa,OAAO;AAAA,EACtE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,KAAK,SAAgC;AAC1C,QAAI,CAAC,KAAK,IAAK,QAAO,QAAQ,QAAQ;AACtC,WAAO,IAAI,QAAc,CAAC,YAAY;AACpC,YAAM,YAAY,KAAK,IAAI;AAC3B,YAAM,eAAe,MAAM;AACzB,YAAI,CAAC,KAAK,KAAK;AACb,kBAAQ;AACR;AAAA,QACF;AAEA,YAAI,KAAK,IAAI,OAAO,GAAG;AACrB,cAAI,KAAK,IAAI,IAAI,YAAY,SAAS;AACpC,iBAAK,IAAI,KAAK;AACd,iBAAK,MAAM;AACX,oBAAQ;AACR;AAAA,UACF;AACA,qBAAW,cAAc,GAAG;AAAA,QAC9B,OAAO;AACL,eAAK,IAAI,KAAK;AACd,eAAK,MAAM;AACX,kBAAQ;AACR;AAAA,QACF;AAAA,MACF;AAEA,mBAAa;AAAA,IACf,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAa,UAAyB;AACpC,QAAI,CAAC,KAAK,IAAK,OAAM,IAAI,MAAM,iDAAiD;AAChF,UAAM,KAAK,IAAI,QAAQ;AAAA,EACzB;AACF;;;AD5DO,IAAM,QAAN,MAKL;AAAA,EACgB;AAAA,EAEC;AAAA,EACA;AAAA,EAET,cAAc;AAAA,EACd,kBAAkB;AAAA,EAE1B,YAAY;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAIG;AACD,QAAI,CAAC,GAAI,OAAM,IAAI,MAAM,uBAAuB;AAChD,QAAI,CAAC,gBAAiB,OAAM,IAAI,MAAM,6BAA6B;AACnE,QAAI,CAAC,KAAK,QAAS,OAAM,IAAI,MAAM,0BAA0B;AAC7D,SAAK,KAAK;AACV,SAAK,mBAAmB;AAExB,SAAK,QAAQ,IAAI,KAAK,KAAK,SAAS,KAAK,OAAO;AAAA,EAClD;AAAA,EAEO,eAAe;AACpB,QAAI,KAAK,YAAa,OAAM,IAAI,MAAM,+CAA+C;AACrF,SAAK,kBAAkB;AACvB,WAAO;AAAA,EACT;AAAA,EAEO,MACL;AAAA,IACE;AAAA,IACA;AAAA,EACF,IAGI;AAAA,IACF,OAAO;AAAA,IACP,kBAAkB;AAAA,EACpB,GACA;AACA,QAAI,KAAK,YAAa,OAAM,IAAI,MAAM,gDAAgD;AACtF,UAAM,mCAAmC,YAAY;AACnD,YAAM,eAAe,MAAM,KAAK,iBAAiB,IAAI;AACrD,UAAI,iBAAkB,OAAM,iBAAiB,YAAY;AAAA,IAC3D;AAEA,UAAM,UAAU,YAAY;AAC1B,UAAI;AACF,YAAI,CAAC,MAAO,OAAM,iCAAiC;AAAA,aAC9C;AACH;AAAA;AAAA,kBAAY,OAAO,sBAAM,KAAK,YAAY,MAAM,QAAQ,MAAM,WAAW,GAAtD;AACnB,gBAAI,KAAM,OAAM,iCAAiC;AAAA,mBADjD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAEF;AAAA,MACF,SAAS,OAAO;AACd,gBAAQ,MAAM,SAAS,KAAK,EAAE,YAAY,KAAK,EAAE;AAAA,MACnD;AAAA,IACF;AACA,SAAK,MAAM,MAAM,OAAO;AACxB,SAAK,cAAc;AAGnB,QAAI,KAAK,gBAAiB,MAAK,MAAM,QAAQ;AAC7C,WAAO;AAAA,EACT;AAAA,EAEA,MAAa,KAAK,UAAU,KAAqB;AAC/C,QAAI,CAAC,KAAK,YAAa,OAAM,IAAI,MAAM,2CAA2C;AAClF,UAAM,KAAK,MAAM,KAAK,OAAO;AAAA,EAC/B;AAAA,EAEA,MAAa,UAAiC;AAE5C,WAAO,MAAM,KAAK,iBAAiB,IAAI;AAAA,EACzC;AAAA,EAEA,MAAc,YAAY,OAAc,aAA6D;AACnG,UAAM,QAAQ,IAAI,MAAM,OAAO,KAAK,IAAI,WAAW;AACnD,UAAM,OAAO,MAAM,MAAM,WAAW;AACpC,QAAI,CAAC,KAAM,QAAO;AAClB,WAAO;AAAA,MACL;AAAA,MACA,CAAC,OAAO,YAAY,GAAG,YAAY;AACjC,YAAI;AACF,gBAAM,MAAM,QAAQ;AAAA,QACtB,SAAS,OAAO;AACd,kBAAQ,MAAM,kCAAkC,KAAK,EAAE,KAAK,KAAK,EAAE;AAAA,QACrE;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;;;AEpGO,IAAM,YAAN,MAAgB;AAAA;AAAA,EAEJ,OAA2F,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQtG,OAGL,OAGC;AACD,SAAK,KAAK,KAAK,KAAK;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,MAAM,OAAe;AAC1B,eAAW,EAAE,KAAK,kBAAkB,KAAK,KAAK,MAAM;AAClD,YAAM,UAAmC,CAAC;AAC1C,UAAI,OAAO;AACT,gBAAQ,QAAQ,EAAE,QAAQ,MAAM;AAAA,MAClC;AACA,UAAI,mBAAmB;AACrB,gBAAQ,mBAAmB;AAAA,MAC7B;AACA,UAAI,MAAM,OAAO;AAAA,IACnB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,KAAK,SAAiB;AACjC,UAAM,QAAQ,IAAI,KAAK,KAAK,IAAI,CAAC,EAAE,IAAI,MAAM,IAAI,KAAK,OAAO,CAAC,CAAC;AAAA,EACjE;AACF;;;ACxDA,SAAS,iBAAiB;;;ACGnB,IAAM,UAAN,MAAkC;AAAA,EAC/B;AAAA,EACA;AAAA,EAER,YAAY,cAAyB;AACnC,SAAK,MAAM,YAAY;AACvB,SAAK,cAAc,QAAQ,QAAQ;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA,EAKA,IAAW,QAAsD;AAC/D,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKO,MAAM,cAA0C;AACrD,QAAI,iBAAiB,UAAa,iBAAiB,MAAM;AACvD,WAAK,SAAS,EAAE,SAAS,aAAa;AAAA,IAGxC,OAAO;AACL,WAAK,SAAS,EAAE,SAAS,OAAU;AAAA,IAGrC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKO,OAAgC,aAAsC;AAC3E,SAAK,cAAc,KAAK,YAAY,KAAK,MAAM;AAI7C,WAAK,SAAS,EAAE,GAAG,KAAK,QAAQ,GAAG,YAAY;AAC/C,aAAO,QAAQ,QAAQ;AAAA,IACzB,CAAC;AACD,WAAO,KAAK;AAAA,EACd;AACF;;;AD5CA,IAAM,QAAQ,UAAU,UAAU;AAE3B,IAAM,YAAN,MAGL;AAAA;AAAA,EAEQ,yBAAkC;AAAA;AAAA,EAElC,gBAAyB,uBAAO,OAAO,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQ5C,WAAW;AAEhB,WAAO,IAAI;AAAA,MACT,KAAK;AAAA,MACL,KAAK;AAAA,IACP;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYO,WAAwB,gBAA0E;AAEvG,SAAK,yBAAyB;AAE9B,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUO,gBAAkE,OAAyB;AAChG,QAAI,OAAO,UAAU,YAAY,UAAU,KAAM,OAAM,IAAI,MAAM,wCAAwC;AAEzG,SAAK,gBAAgB;AAErB,WAAO;AAAA,EACT;AACF;AAEA,IAAM,mBAAN,MAIE;AAAA,EAIA,YACU,eACA,wBACR;AAFQ;AACA;AAAA,EACP;AAAA,EANc,SAAS,oBAAI,IAA+E;AAAA,EAC5F,oBAA8B,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA2BzC,QACL,SACA;AACA,UAAM,SAAS,QAAQ;AACvB,QAAI,KAAK,OAAO,IAAI,MAAM,EAAG,OAAM,IAAI,MAAM,gBAAgB,MAAM,iBAAiB;AACpF,UAAM,OAAO,IAAI,KAAsE,OAAO;AAC9F,SAAK,OAAO,IAAI,QAAQ,IAAI;AAE5B,eAAW,SAAS,QAAQ,gBAAgB,CAAC,GAAG;AAC9C,UAAI,OAAO,UAAU,SAAU,OAAM,IAAI,MAAM,gCAAgC;AAC/E,YAAM,gBAAgB,KAAK,OAAO,IAAI,KAAK;AAC3C,UAAI,CAAC,cAAe,OAAM,IAAI,MAAM,cAAc,KAAK,uBAAuB,MAAM,EAAE;AACtF,WAAK,cAAc,KAAK;AAAA,IAC1B;AAEA,WAAO;AAAA,EAQT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUO,QAAQ;AACb,QAAI,CAAC,KAAK,KAAM,OAAM,IAAI,MAAM,8DAA8D;AAC9F,SAAK,iBAAiB;AACtB,WAAO,IAAI,gBAAgB,KAAK,eAAe,KAAK,wBAAwB,KAAK,mBAAmB,KAAK,MAAM;AAAA,EACjH;AAAA;AAAA;AAAA;AAAA,EAKA,IAAW,OAAO;AAChB,WAAO,KAAK,OAAO;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAKQ,mBAAmB;AACzB,UAAM,UAAU,oBAAI,IAAY;AAChC,UAAM,OAAO,oBAAI,IAAY;AAE7B,UAAM,QAAQ,CAAC,WAAmB;AAChC,UAAI,KAAK,IAAI,MAAM,EAAG,OAAM,IAAI,MAAM,+CAA+C,MAAM,EAAE;AAC7F,UAAI,CAAC,QAAQ,IAAI,MAAM,GAAG;AACxB,aAAK,IAAI,MAAM;AACf,cAAM,OAAO,KAAK,OAAO,IAAI,MAAM;AACnC,YAAI,CAAC,KAAM,OAAM,IAAI,MAAM,QAAQ,MAAM,YAAY;AACrD,mBAAW,SAAS,KAAK,aAAc,OAAM,KAAK;AAClD,aAAK,OAAO,MAAM;AAClB,gBAAQ,IAAI,MAAM;AAClB,aAAK,kBAAkB,KAAK,MAAM;AAAA,MACpC;AAAA,IACF;AAEA,eAAW,UAAU,KAAK,OAAO,KAAK,EAAG,KAAI,CAAC,QAAQ,IAAI,MAAM,EAAG,OAAM,MAAM;AAC/E,YAAQ,MAAM;AACd,SAAK,MAAM;AAAA,EACb;AACF;AAEO,IAAM,kBAAN,MAGL;AAAA,EAGA,YACU,eACA,wBACS,mBACA,QACjB;AAJQ;AACA;AACS;AACA;AAAA,EAChB;AAAA,EAPc,UAAU,IAAI,QAA+C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgB9E,MAAM,MAA6B;AACjC,QAAI,KAAK,kBAAkB,WAAW;AACpC,YAAM,IAAI,MAAM,0DAA0D;AAE5E,QAAI;AACJ,QAAI,KAAK,wBAAwB;AAC/B,cACE,OAAO,KAAK,2BAA2B,aACnC,MAAO,KAAK,uBAA4F,IACxG,KAAK;AAAA,IACb;AACA,SAAK,QAAQ,MAAM,KAAK;AAExB,UAAM,YAAY,oBAAI,IAAY;AAClC,UAAM,UAAU,oBAAI,IAA2B;AAC/C,UAAM,aAAa,IAAI;AAAA,MACrB,KAAK,kBAAkB,OAAO,CAAC,WAAW,KAAK,OAAO,IAAI,MAAM,GAAG,aAAa,WAAW,CAAC;AAAA,IAC9F;AAEA,UAAM,UAAU,OAAO,WAAmB;AACxC,YAAM,OAAO,KAAK,OAAO,IAAI,MAAM;AACnC,UAAI,CAAC,KAAM,OAAM,IAAI,MAAM,QAAQ,MAAM,YAAY;AAErD,UAAI;AACF,cAAM,SAAS,MAAM,KAAK,IAAI,KAAK,eAAe,KAAK,QAAQ,KAAK;AACpE,cAAM,KAAK,QAAQ,OAAO,EAAE,CAAC,MAAM,GAAG,OAAO,CAAC;AAC9C,kBAAU,IAAI,MAAM;AAAA,MACtB,QAAQ;AAEN,kBAAU,IAAI,MAAM;AAAA,MACtB,UAAE;AACA,gBAAQ,OAAO,MAAM;AAGrB,mBAAW,CAAC,IAAI,CAAC,KAAK,KAAK,QAAQ;AACjC,cAAI,CAAC,UAAU,IAAI,EAAE,KAAK,CAAC,QAAQ,IAAI,EAAE,GAAG;AAC1C,kBAAM,SAAS,EAAE,aAAa,MAAM,CAAC,UAAU;AAC7C,oBAAM,UAAU,KAAK,OAAO,IAAI,KAAK;AACrC,qBAAO,WAAW,UAAU,IAAI,KAAK,KAAK,QAAQ,WAAW;AAAA,YAC/D,CAAC;AACD,gBAAI,OAAQ,YAAW,IAAI,EAAE;AAAA,UAC/B;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,WAAO,UAAU,OAAO,KAAK,OAAO,MAAM;AAExC,iBAAW,UAAU,YAAY;AAC/B,mBAAW,OAAO,MAAM;AACxB,cAAM,UAAU,QAAQ,MAAM;AAC9B,gBAAQ,IAAI,QAAQ,OAAO;AAAA,MAC7B;AAGA,UAAI,QAAQ,OAAO,GAAG;AACpB,cAAM,QAAQ,KAAK,QAAQ,OAAO,CAAC;AAAA,MACrC,OAAO;AAGL;AAAA,MACF;AAAA,IACF;AAEA,WAAO,KAAK,QAAQ;AAAA,EACtB;AACF;AAEA,IAAM,OAAN,MAKE;AAAA,EAMA,YAA6B,SAAoF;AAApF;AAC3B,QAAI,QAAQ,YAAa,MAAK,eAAe,QAAQ;AAAA,EACvD;AAAA,EAPiB,gBAAmC,CAAC;AAAA,EAE7C,eAA4B,EAAE,YAAY,GAAG,cAAc,EAAE;AAAA,EAC7D,UAAsB;AAAA,EAMvB,cAAc,QAAyB;AAC5C,SAAK,cAAc,KAAK,MAAM;AAAA,EAChC;AAAA,EAEA,IAAW,eAAe;AACxB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAW,KAAK;AACd,WAAO,KAAK,QAAQ;AAAA,EACtB;AAAA,EAEA,MAAa,IAAI,MAAyB,KAAyC;AAEjF,aAAS,UAAU,GAAG,UAAU,KAAK,aAAa,aAAa,GAAG,WAAW;AAC3E,UAAI;AACF,aAAK,UAAU;AACf,cAAM,SAAS,MAAM,KAAK,QAAQ,QAAQ,EAAE,MAAM,IAAI,CAAC;AACvD,aAAK,UAAU;AACf,eAAO;AAAA,MACT,SAAS,KAAK;AACZ,YAAI,YAAY,KAAK,aAAa,YAAY;AAC5C,kBAAQ,MAAM,qBAAqB,UAAU,CAAC,cAAc,GAAG,EAAE;AACjE,gBAAM,QAAQ,eAAe,QAAQ,MAAM,IAAI,MAAM,oBAAoB,OAAO,GAAG,CAAC,EAAE;AACtF,cAAI;AACF,gBAAI,KAAK,QAAQ,aAAc,OAAM,KAAK,QAAQ,aAAa,OAAO,EAAE,MAAM,IAAI,CAAC;AAAA,gBAC9E,SAAQ,MAAM,iBAAiB,KAAK,QAAQ,EAAE,KAAK,GAAG,EAAE;AAAA,UAC/D,SAASA,QAAO;AACd,oBAAQ,MAAM,mCAAmC,KAAK,QAAQ,EAAE,KAAKA,MAAK,EAAE;AAAA,UAC9E;AACA,eAAK,UAAU;AACf,gBAAM;AAAA,QACR;AACA,gBAAQ,MAAM,kCAAkC,UAAU,CAAC,IAAI,KAAK,aAAa,UAAU,MAAM,GAAG,EAAE;AACtG,cAAM,MAAM,KAAK,aAAa,YAAY;AAAA,MAC5C;AAAA,IACF;AAIA,UAAM,IAAI,MAAM,8BAA8B;AAAA,EAChD;AAAA,EAEA,IAAW,SAAS;AAClB,WAAO,KAAK;AAAA,EACd;AACF;","names":["error"]}