{"version":3,"sources":["../src/clujo.ts","../src/task-graph-builder.ts","../src/context.ts","../src/task-graph.ts","../src/cron.ts","../src/clujo-builder.ts","../src/scheduler.ts"],"sourcesContent":["import type { Redis } from \"ioredis\";\nimport { type LockOptions, Mutex } from \"redis-semaphore\";\nimport type { IClujo, ILock, StartOptions, TErrorHandler, TExecute } from \"./clujo.types\";\nimport type { ICron } from \"./cron.types\";\nimport { TaskGraphBuilder } from \"./task-graph-builder\";\nimport type { ITask, ITaskGraphBuilderHelper, RetryPolicy, TaskMap } from \"./task-graph.types\";\n\nexport class Clujo<TDependencies, TContext extends object, TTaskMap extends TaskMap<TDependencies, TContext>>\n  implements IClujo<TDependencies, TContext, TTaskMap>\n{\n  private readonly taskGraphBuilder: ITaskGraphBuilderHelper<TDependencies, TContext, TTaskMap>;\n  private hasStarted = false;\n\n  constructor(\n    public readonly id: string,\n    private readonly cron: ICron,\n    private readonly retryPolicy: RetryPolicy,\n    private readonly runImmediately: boolean,\n    dependencies: TDependencies,\n    contextValueOrFactory: undefined | TContext | (() => TContext | Promise<TContext>),\n  ) {\n    this.taskGraphBuilder = new TaskGraphBuilder<TDependencies, TContext>()\n      .setDependencies(dependencies)\n      .setInitialContext(contextValueOrFactory)\n      .finalizeSetup();\n  }\n\n  addTask<TTaskId extends string, TExecuteReturn>(input: {\n    taskId: TTaskId;\n    // pick the keys of TTaskMap in TContext\n    execute: TExecute<TDependencies, TContext, TExecuteReturn>;\n    errorHandler?: TErrorHandler<TDependencies, TContext>;\n    retryPolicy?: RetryPolicy;\n    dependencies?: (keyof TTaskMap)[];\n  }): IClujo<\n    TDependencies,\n    TContext &\n      Partial<{\n        [K in TTaskId]: TExecuteReturn extends void ? undefined : TExecuteReturn;\n      }>,\n    TTaskMap & {\n      [K in TTaskId]: ITask<\n        TDependencies,\n        TExecuteReturn,\n        TContext &\n          Partial<{\n            [K in TTaskId]: TExecuteReturn extends void ? undefined : TExecuteReturn;\n          }>\n      >;\n    }\n  > {\n    if (this.hasStarted) throw new Error(\"Cannot add a task after the Clujo has started.\");\n    this.taskGraphBuilder.addTask({\n      id: input.taskId,\n      execute: input.execute,\n      errorHandler: input.errorHandler,\n      retryPolicy: input.retryPolicy ?? this.retryPolicy,\n      dependencies: input.dependencies as string[] | undefined,\n    });\n    return this as unknown as IClujo<\n      TDependencies,\n      TContext & { [K in TTaskId]: TExecuteReturn extends void ? undefined : TExecuteReturn },\n      TTaskMap & {\n        [K in TTaskId]: ITask<\n          TDependencies,\n          TExecuteReturn,\n          TContext & { [K in TTaskId]: TExecuteReturn extends void ? undefined : TExecuteReturn }\n        >;\n      }\n    >;\n  }\n\n  start(options?: StartOptions<TContext>): IClujo<TDependencies, TContext, TTaskMap> {\n    if (this.hasStarted) throw new Error(\"Cannot start a Clujo that has already been started.\");\n    if (!this.taskGraphBuilder.size) throw new Error(\"Cannot start a Clujo with no added tasks.\");\n    // run the topological sort only once\n    const runTasks = this.taskGraphBuilder.build().run;\n    const redis = options?.redis;\n\n    const executeTasksAndCompletionHandler = async () => {\n      const finalContext = await runTasks();\n      if (options?.completionHandler) await options.completionHandler(finalContext);\n    };\n\n    const handler = async () => {\n      try {\n        if (!redis) {\n          await executeTasksAndCompletionHandler();\n        } else {\n          await using lock = await this.tryAcquire(redis, options?.options);\n          if (lock) {\n            await executeTasksAndCompletionHandler();\n          }\n        }\n      } catch (error) {\n        console.error(`Clujo ${this.id} failed: ${error}`);\n      }\n    };\n    this.cron.start(handler);\n    this.hasStarted = true;\n    if (this.runImmediately) this.trigger();\n    return this;\n  }\n\n  async stop(): Promise<void> {\n    if (!this.hasStarted) throw new Error(\"Cannot stop a Clujo that has not been started.\");\n    await this.cron.stop();\n  }\n\n  async trigger(): Promise<void> {\n    if (!this.hasStarted) throw new Error(\"Cannot trigger a Clujo that has not been started.\");\n    await this.cron.trigger();\n  }\n\n  private async tryAcquire(redis: Redis, lockOptions: LockOptions | undefined): Promise<ILock | null> {\n    const mutex = new Mutex(redis, this.id, lockOptions);\n    const lock = await mutex.tryAcquire();\n    if (!lock) return null;\n    return {\n      mutex,\n      [Symbol.asyncDispose]: async () => {\n        try {\n          await mutex.release();\n        } catch (error) {\n          console.error(`Error releasing lock for Clujo ${this.id}: ${error}`);\n        }\n      },\n    };\n  }\n}\n","import { promisify } from \"node:util\";\nimport { TaskGraph } from \"./task-graph\";\nimport type {\n  ITask,\n  ITaskGraph,\n  ITaskGraphBuilder,\n  ITaskGraphBuilderHelper,\n  RetryPolicy,\n  TaskMap,\n  TaskOptions,\n} from \"./task-graph.types\";\n\nconst sleep = promisify(setTimeout);\n\nclass Task<TCommonInput, TContextInput, TReturn> implements ITask<TCommonInput, TContextInput, TReturn> {\n  private readonly _dependencies: string[] = [];\n  private _retryPolicy: RetryPolicy = { maxRetries: 0, retryDelayMs: 0 };\n\n  constructor(\n    private readonly options: TaskOptions<string, TCommonInput, TContextInput, TReturn, string | number | symbol>,\n  ) {\n    if (options.retryPolicy) this._retryPolicy = options.retryPolicy;\n  }\n\n  public get id() {\n    return this.options.id;\n  }\n\n  public get dependencies() {\n    return this._dependencies;\n  }\n\n  public addDependency(taskId: string) {\n    this._dependencies.push(taskId);\n  }\n\n  public async run(deps: TCommonInput, ctx: TContextInput): Promise<TReturn> {\n    // we retry maxRetries times on top of the initial attempt\n    for (let attempt = 0; attempt < this._retryPolicy.maxRetries + 1; attempt++) {\n      try {\n        return await this.options.execute({ deps, ctx });\n      } catch (err) {\n        if (attempt === this._retryPolicy.maxRetries) {\n          console.error(`Task failed after ${attempt + 1} attempts: ${err}`);\n          const error = err instanceof Error ? err : new Error(`Non error throw: ${String(err)}`);\n          try {\n            if (this.options.errorHandler) await this.options.errorHandler(error, { deps, ctx });\n            else console.error(`Error in task ${this.options.id}: ${err}`);\n          } catch (error) {\n            console.error(`Error in task error handler for ${this.options.id}: ${error}`);\n          }\n          throw error;\n        }\n        console.error(`Task failed, retrying (attempt ${attempt + 1}/${this._retryPolicy.maxRetries}): ${err}`);\n        await sleep(this._retryPolicy.retryDelayMs);\n      }\n    }\n\n    // This line should never be reached due to the for loop condition,\n    // but TypeScript requires a return statement here\n    throw new Error(\"Unexpected end of run method\");\n  }\n}\n\nexport class TaskGraphBuilder<TDependencies, TContext extends object>\n  implements ITaskGraphBuilder<TDependencies, TContext>\n{\n  private contextValueOrFactory: unknown = undefined;\n  private dependencies!: TDependencies;\n\n  finalizeSetup() {\n    // biome-ignore lint/complexity/noBannedTypes: <explanation>\n    return new TaskGraphBuilderHelper<TDependencies, TContext, {}>(\n      this.dependencies,\n      this.contextValueOrFactory as undefined | TContext | (() => TContext | Promise<TContext>),\n    );\n  }\n\n  setDependencies<TNewDependencies>(value?: undefined | TNewDependencies) {\n    this.dependencies = value as unknown as TDependencies;\n    return this as unknown as ITaskGraphBuilder<TNewDependencies, TContext>;\n  }\n\n  setInitialContext<TNewContext extends object>(\n    valueOrFactory?: undefined | TNewContext | (() => TNewContext | Promise<TNewContext>),\n  ) {\n    this.contextValueOrFactory = valueOrFactory;\n    return this as unknown as ITaskGraphBuilder<TDependencies, TNewContext>;\n  }\n}\n\nexport class TaskGraphBuilderHelper<\n  TDependencies,\n  TContext extends object,\n  TTaskMap extends TaskMap<TDependencies, TContext>,\n> implements ITaskGraphBuilderHelper<TDependencies, TContext, TTaskMap>\n{\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  private readonly tasks: Map<string, ITask<TDependencies, TContext, any>> = new Map();\n  private readonly order: string[] = [];\n\n  constructor(\n    private readonly dependencies: TDependencies,\n    private readonly contextValueOrFactory: undefined | TContext | (() => TContext | Promise<TContext>),\n  ) {}\n\n  public get size() {\n    return this.tasks.size;\n  }\n\n  build(): ITaskGraph<TContext> {\n    this.topologicalSort();\n    return new TaskGraph(this.dependencies, this.contextValueOrFactory, this.tasks, this.order);\n  }\n\n  addTask<TTaskId extends string, TReturn>(\n    options: TaskOptions<TTaskId, TDependencies, TContext, TReturn, keyof TTaskMap>,\n  ): ITaskGraphBuilderHelper<\n    TDependencies,\n    TContext & Partial<{ [K in TTaskId]: TReturn }>,\n    TTaskMap & { [K in TTaskId]: ITask<TDependencies, TContext & Partial<{ [K in TTaskId]: TReturn }>, TReturn> }\n  > {\n    const taskId = options.id;\n    if (this.tasks.has(taskId)) {\n      throw new Error(`Task with id ${taskId} already exists`);\n    }\n    const task = new Task(options);\n    this.tasks.set(taskId, task);\n\n    for (const depId of options.dependencies ?? []) {\n      if (typeof depId !== \"string\") throw new Error(\"Dependency ID must be a string\");\n      const dependentTask = this.tasks.get(depId);\n      if (!dependentTask) throw new Error(`Dependency ${depId} not found for task ${taskId}`);\n      task.addDependency(depId);\n    }\n\n    return this as unknown as ITaskGraphBuilderHelper<\n      TDependencies,\n      TContext & Partial<{ [K in TTaskId]: TReturn }>,\n      TTaskMap & { [K in TTaskId]: ITask<TDependencies, TContext & Partial<{ [K in TTaskId]: TReturn }>, TReturn> }\n    >;\n  }\n\n  private topologicalSort() {\n    const visited = new Set<string>();\n    const temp = new Set<string>();\n\n    const visit = (taskId: string) => {\n      if (temp.has(taskId)) {\n        throw new Error(`Circular dependency detected involving task ${taskId}`);\n      }\n      if (!visited.has(taskId)) {\n        temp.add(taskId);\n        const task = this.tasks.get(taskId);\n        if (!task) throw new Error(`Task ${taskId} not found`);\n\n        for (const depId of task.dependencies) {\n          visit(depId);\n        }\n\n        temp.delete(taskId);\n        visited.add(taskId);\n        this.order.push(taskId);\n      }\n    };\n\n    for (const taskId of this.tasks.keys()) {\n      if (!visited.has(taskId)) {\n        visit(taskId);\n      }\n    }\n  }\n}\n","export class Context<T extends object> {\n  private object!: { initial: object | undefined } & T;\n  private updateQueue: Promise<void>;\n\n  constructor(initialObject?: object) {\n    this.reset(initialObject);\n    this.updateQueue = Promise.resolve();\n  }\n\n  public get value(): { initial: object | undefined } & T {\n    return this.object;\n  }\n\n  public reset(initialObject?: object): void {\n    if (initialObject) {\n      this.object = { initial: { ...initialObject } } as { initial: object | undefined } & T;\n    } else {\n      this.object = { initial: undefined } as { initial: object | undefined } & T;\n    }\n  }\n\n  update<NewValue extends object>(updateValue: NewValue): Promise<void> {\n    this.updateQueue = this.updateQueue.then(() => {\n      this.object = { ...this.object, ...updateValue };\n      return Promise.resolve();\n    });\n    return this.updateQueue;\n  }\n}\n","import { Context } from \"./context\";\nimport type { ITask, ITaskGraph } from \"./task-graph.types\";\n\nexport class TaskGraph<TDependencies, TContext extends object> implements ITaskGraph<TContext> {\n  private readonly context: Context<TContext> = new Context<TContext>();\n\n  constructor(\n    private readonly taskDependencies: TDependencies,\n    private readonly contextValueOrFactory: undefined | TContext | (() => TContext | Promise<TContext>),\n    private readonly tasks: Map<string, ITask<TDependencies, TContext, unknown>>,\n    private readonly order: string[],\n  ) {}\n\n  run = async (): Promise<Required<TContext>> => {\n    if (this.order.length === 0) throw new Error(\"No tasks to run. Did you forget to call topologicalSort?\");\n    let value: TContext | undefined;\n    if (this.contextValueOrFactory) {\n      value =\n        typeof this.contextValueOrFactory === \"function\"\n          ? await this.contextValueOrFactory()\n          : this.contextValueOrFactory;\n    }\n    this.context.reset(value);\n\n    const completed = new Set<string>();\n    const running = new Map<string, Promise<void>>();\n    const readyTasks = new Set<string>(\n      this.order.filter((taskId) => this.tasks.get(taskId)?.dependencies.length === 0),\n    );\n\n    const runTask = async (taskId: string) => {\n      const task = this.tasks.get(taskId);\n      if (!task) throw new Error(`Task ${taskId} not found`);\n\n      try {\n        const result = await task.run(this.taskDependencies, this.context.value);\n        await this.context.update({ [taskId]: result });\n        completed.add(taskId);\n      } finally {\n        running.delete(taskId);\n\n        // Check if any dependent tasks are now ready to run\n        for (const [id, t] of this.tasks) {\n          if (!completed.has(id) && !running.has(id) && t.dependencies.every((depId) => completed.has(depId))) {\n            readyTasks.add(id);\n          }\n        }\n      }\n    };\n\n    while (completed.size < this.tasks.size) {\n      // Start all ready tasks\n      for (const taskId of readyTasks) {\n        readyTasks.delete(taskId);\n        const promise = runTask(taskId);\n        running.set(taskId, promise);\n      }\n\n      // Wait for at least one task to complete\n      if (running.size > 0) {\n        await Promise.race(running.values());\n      }\n    }\n\n    return this.context.value as Required<TContext>;\n  };\n}\n","import Croner, { type CronOptions } from \"croner\";\nimport type { ICron } from \"./cron.types\";\n\nexport class Cron implements ICron {\n  private job: Croner | null = null;\n\n  constructor(\n    private readonly cronExpression: string,\n    private readonly cronOptions?: CronOptions,\n  ) {}\n\n  start(handler: () => Promise<void> | void): void {\n    if (this.job) throw new Error(\"Attempting to start an already started job\");\n    this.job = new Croner(this.cronExpression, this.cronOptions, handler);\n  }\n\n  stop(): Promise<void> {\n    return new Promise<void>((resolve) => {\n      const checkAndStop = () => {\n        if (this.job?.isBusy()) setTimeout(checkAndStop, 100);\n        else {\n          this.job?.stop();\n          resolve();\n        }\n      };\n      checkAndStop();\n    });\n  }\n\n  async trigger(): Promise<void> {\n    if (!this.job) throw new Error(\"Attempting to trigger a non-started job\");\n    await this.job.trigger();\n  }\n}\n","import type { CronOptions } from \"croner\";\nimport { Clujo } from \"./clujo\";\nimport type { IClujo, IClujoBuilder, IClujoStart } from \"./clujo.types\";\nimport { Cron } from \"./cron\";\nimport type { ICron } from \"./cron.types\";\nimport type { RetryPolicy } from \"./task-graph.types\";\n\n/**\n * A builder class for creating and configuring a Clujo instance.\n *\n * @implements {IClujoStart}\n *\n * @description\n * The ClujoBuilder provides a fluent interface for setting up a Clujo with various configurations.\n * It allows you to define the schedule, set dependencies, configure the context, and apply retry policies.\n *\n * @example\n * ```typescript\n * const clujo = new ClujoBuilder('myClujoId')\n *   .setSchedule('* * * * *')                                // cron schedule to run on\n *   .setDependencies({ db: myDatabase })                     // every task has access to the database\n *   .setContext({ initialValue: 0 })                         // initial context value (can also be a function returning a value)\n *   .setRetryPolicy({ maxRetries: 3, retryDelayMs: 1000 })   // global retry policy (can be overriden by task)\n *   .runOnStartup()                                          // run this task immediately when the Clujo starts\n *   .build();                                                // build the Clujo instance\n * ```\n *\n * @see {@link IClujoStart} for the initial interface implemented by ClujoBuilder.\n * @see {@link IClujoBuilder} for the interface returned after setting the schedule.\n * @see {@link IClujo} for the final Clujo interface after building.\n */\nexport class ClujoBuilder implements IClujoStart {\n\tconstructor(private readonly id: string) {}\n\n\tsetSchedule(\n\t\tpattern: string,\n\t\toptions?: CronOptions,\n\t): IClujoBuilder<void, { initial: undefined }> {\n\t\t// TODO: validate this pattern?\n\t\tconst cron = new Cron(pattern, options);\n\t\treturn new ClujoBuilderHelper(this.id, cron);\n\t}\n}\n\nclass ClujoBuilderHelper<TDependencies, TContext extends object>\n\timplements IClujoBuilder<TDependencies, TContext>\n{\n\t// do not retry by default\n\tprivate retryPolicy: RetryPolicy = { maxRetries: 0, retryDelayMs: 0 };\n\t// do not run immediately by default\n\tprivate runImmediately = false;\n\t// do not set initial context by default\n\tprivate contextValueOrFactory: unknown = undefined;\n\tprivate dependencies!: TDependencies;\n\n\tconstructor(\n\t\tprivate readonly id: string,\n\t\tprivate readonly cron: ICron,\n\t) {}\n\n\t// biome-ignore lint/complexity/noBannedTypes: valid use case here\n\tbuild(): IClujo<TDependencies, TContext, {}> {\n\t\t// biome-ignore lint/complexity/noBannedTypes: valid use case here\n\t\treturn new Clujo<TDependencies, TContext, {}>(\n\t\t\tthis.id,\n\t\t\tthis.cron,\n\t\t\tthis.retryPolicy,\n\t\t\tthis.runImmediately,\n\t\t\tthis.dependencies,\n\t\t\tthis.contextValueOrFactory as\n\t\t\t\t| undefined\n\t\t\t\t| TContext\n\t\t\t\t| (() => TContext | Promise<TContext>),\n\t\t);\n\t}\n\n\trunOnStartup(): IClujoBuilder<TDependencies, TContext> {\n\t\tthis.runImmediately = true;\n\t\treturn this;\n\t}\n\n\tsetDependencies<TNewDeps extends object>(\n\t\tdeps: TNewDeps,\n\t): IClujoBuilder<TNewDeps, TContext> {\n\t\tthis.dependencies = deps as unknown as TDependencies;\n\t\treturn this as unknown as IClujoBuilder<TNewDeps, TContext>;\n\t}\n\n\tsetInitialContext<TNewContext>(\n\t\tvalueOrFactory: TNewContext | (() => TNewContext | Promise<TNewContext>),\n\t): IClujoBuilder<TDependencies, { initial: TNewContext }> {\n\t\tthis.contextValueOrFactory = valueOrFactory;\n\t\treturn this as unknown as IClujoBuilder<\n\t\t\tTDependencies,\n\t\t\t{ initial: TNewContext }\n\t\t>;\n\t}\n\n\tsetRetryPolicy(policy: RetryPolicy): IClujoBuilder<TDependencies, TContext> {\n\t\tthis.retryPolicy = policy;\n\t\treturn this;\n\t}\n}\n","import type Redis from \"ioredis\";\nimport type { IClujo } from \"./clujo.types\";\nimport type { TaskMap } from \"./task-graph.types\";\n\nexport class Scheduler {\n  // biome-ignore lint/suspicious/noExplicitAny: handle any combination of clujo's\n  private readonly jobs: { job: IClujo<any, any, any>; completionHandler: (ctx: any) => Promise<void> | void }[] = [];\n\n  addJob<TDependencies, TContext>(input: {\n    // biome-ignore lint/suspicious/noExplicitAny: I do not want to type this\n    job: IClujo<TDependencies, TContext, any>;\n    completionHandler: (ctx: Required<TContext>) => Promise<void> | void;\n  }) {\n    this.jobs.push(input);\n  }\n\n  start(redis?: Redis) {\n    for (const { job } of this.jobs) {\n      job.start({ redis });\n    }\n  }\n\n  async stop() {\n    await Promise.all(this.jobs.map(({ job }) => job.stop()));\n  }\n}\n"],"mappings":";AACA,SAA2B,aAAa;;;ACDxC,SAAS,iBAAiB;;;ACAnB,IAAM,UAAN,MAAgC;AAAA,EAIrC,YAAY,eAAwB;AAClC,SAAK,MAAM,aAAa;AACxB,SAAK,cAAc,QAAQ,QAAQ;AAAA,EACrC;AAAA,EAEA,IAAW,QAA6C;AACtD,WAAO,KAAK;AAAA,EACd;AAAA,EAEO,MAAM,eAA8B;AACzC,QAAI,eAAe;AACjB,WAAK,SAAS,EAAE,SAAS,EAAE,GAAG,cAAc,EAAE;AAAA,IAChD,OAAO;AACL,WAAK,SAAS,EAAE,SAAS,OAAU;AAAA,IACrC;AAAA,EACF;AAAA,EAEA,OAAgC,aAAsC;AACpE,SAAK,cAAc,KAAK,YAAY,KAAK,MAAM;AAC7C,WAAK,SAAS,EAAE,GAAG,KAAK,QAAQ,GAAG,YAAY;AAC/C,aAAO,QAAQ,QAAQ;AAAA,IACzB,CAAC;AACD,WAAO,KAAK;AAAA,EACd;AACF;;;ACzBO,IAAM,YAAN,MAAwF;AAAA,EAG7F,YACmB,kBACA,uBACA,OACA,OACjB;AAJiB;AACA;AACA;AACA;AANnB,SAAiB,UAA6B,IAAI,QAAkB;AASpE,eAAM,YAAyC;AAC7C,UAAI,KAAK,MAAM,WAAW,EAAG,OAAM,IAAI,MAAM,0DAA0D;AACvG,UAAI;AACJ,UAAI,KAAK,uBAAuB;AAC9B,gBACE,OAAO,KAAK,0BAA0B,aAClC,MAAM,KAAK,sBAAsB,IACjC,KAAK;AAAA,MACb;AACA,WAAK,QAAQ,MAAM,KAAK;AAExB,YAAM,YAAY,oBAAI,IAAY;AAClC,YAAM,UAAU,oBAAI,IAA2B;AAC/C,YAAM,aAAa,IAAI;AAAA,QACrB,KAAK,MAAM,OAAO,CAAC,WAAW,KAAK,MAAM,IAAI,MAAM,GAAG,aAAa,WAAW,CAAC;AAAA,MACjF;AAEA,YAAM,UAAU,OAAO,WAAmB;AACxC,cAAM,OAAO,KAAK,MAAM,IAAI,MAAM;AAClC,YAAI,CAAC,KAAM,OAAM,IAAI,MAAM,QAAQ,MAAM,YAAY;AAErD,YAAI;AACF,gBAAM,SAAS,MAAM,KAAK,IAAI,KAAK,kBAAkB,KAAK,QAAQ,KAAK;AACvE,gBAAM,KAAK,QAAQ,OAAO,EAAE,CAAC,MAAM,GAAG,OAAO,CAAC;AAC9C,oBAAU,IAAI,MAAM;AAAA,QACtB,UAAE;AACA,kBAAQ,OAAO,MAAM;AAGrB,qBAAW,CAAC,IAAI,CAAC,KAAK,KAAK,OAAO;AAChC,gBAAI,CAAC,UAAU,IAAI,EAAE,KAAK,CAAC,QAAQ,IAAI,EAAE,KAAK,EAAE,aAAa,MAAM,CAAC,UAAU,UAAU,IAAI,KAAK,CAAC,GAAG;AACnG,yBAAW,IAAI,EAAE;AAAA,YACnB;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,aAAO,UAAU,OAAO,KAAK,MAAM,MAAM;AAEvC,mBAAW,UAAU,YAAY;AAC/B,qBAAW,OAAO,MAAM;AACxB,gBAAM,UAAU,QAAQ,MAAM;AAC9B,kBAAQ,IAAI,QAAQ,OAAO;AAAA,QAC7B;AAGA,YAAI,QAAQ,OAAO,GAAG;AACpB,gBAAM,QAAQ,KAAK,QAAQ,OAAO,CAAC;AAAA,QACrC;AAAA,MACF;AAEA,aAAO,KAAK,QAAQ;AAAA,IACtB;AAAA,EAtDG;AAuDL;;;AFtDA,IAAM,QAAQ,UAAU,UAAU;AAElC,IAAM,OAAN,MAAwG;AAAA,EAItG,YACmB,SACjB;AADiB;AAJnB,SAAiB,gBAA0B,CAAC;AAC5C,SAAQ,eAA4B,EAAE,YAAY,GAAG,cAAc,EAAE;AAKnE,QAAI,QAAQ,YAAa,MAAK,eAAe,QAAQ;AAAA,EACvD;AAAA,EAEA,IAAW,KAAK;AACd,WAAO,KAAK,QAAQ;AAAA,EACtB;AAAA,EAEA,IAAW,eAAe;AACxB,WAAO,KAAK;AAAA,EACd;AAAA,EAEO,cAAc,QAAgB;AACnC,SAAK,cAAc,KAAK,MAAM;AAAA,EAChC;AAAA,EAEA,MAAa,IAAI,MAAoB,KAAsC;AAEzE,aAAS,UAAU,GAAG,UAAU,KAAK,aAAa,aAAa,GAAG,WAAW;AAC3E,UAAI;AACF,eAAO,MAAM,KAAK,QAAQ,QAAQ,EAAE,MAAM,IAAI,CAAC;AAAA,MACjD,SAAS,KAAK;AACZ,YAAI,YAAY,KAAK,aAAa,YAAY;AAC5C,kBAAQ,MAAM,qBAAqB,UAAU,CAAC,cAAc,GAAG,EAAE;AACjE,gBAAM,QAAQ,eAAe,QAAQ,MAAM,IAAI,MAAM,oBAAoB,OAAO,GAAG,CAAC,EAAE;AACtF,cAAI;AACF,gBAAI,KAAK,QAAQ,aAAc,OAAM,KAAK,QAAQ,aAAa,OAAO,EAAE,MAAM,IAAI,CAAC;AAAA,gBAC9E,SAAQ,MAAM,iBAAiB,KAAK,QAAQ,EAAE,KAAK,GAAG,EAAE;AAAA,UAC/D,SAASA,QAAO;AACd,oBAAQ,MAAM,mCAAmC,KAAK,QAAQ,EAAE,KAAKA,MAAK,EAAE;AAAA,UAC9E;AACA,gBAAM;AAAA,QACR;AACA,gBAAQ,MAAM,kCAAkC,UAAU,CAAC,IAAI,KAAK,aAAa,UAAU,MAAM,GAAG,EAAE;AACtG,cAAM,MAAM,KAAK,aAAa,YAAY;AAAA,MAC5C;AAAA,IACF;AAIA,UAAM,IAAI,MAAM,8BAA8B;AAAA,EAChD;AACF;AAEO,IAAM,mBAAN,MAEP;AAAA,EAFO;AAGL,SAAQ,wBAAiC;AAAA;AAAA,EAGzC,gBAAgB;AAEd,WAAO,IAAI;AAAA,MACT,KAAK;AAAA,MACL,KAAK;AAAA,IACP;AAAA,EACF;AAAA,EAEA,gBAAkC,OAAsC;AACtE,SAAK,eAAe;AACpB,WAAO;AAAA,EACT;AAAA,EAEA,kBACE,gBACA;AACA,SAAK,wBAAwB;AAC7B,WAAO;AAAA,EACT;AACF;AAEO,IAAM,yBAAN,MAKP;AAAA,EAKE,YACmB,cACA,uBACjB;AAFiB;AACA;AALnB;AAAA,SAAiB,QAA0D,oBAAI,IAAI;AACnF,SAAiB,QAAkB,CAAC;AAAA,EAKjC;AAAA,EAEH,IAAW,OAAO;AAChB,WAAO,KAAK,MAAM;AAAA,EACpB;AAAA,EAEA,QAA8B;AAC5B,SAAK,gBAAgB;AACrB,WAAO,IAAI,UAAU,KAAK,cAAc,KAAK,uBAAuB,KAAK,OAAO,KAAK,KAAK;AAAA,EAC5F;AAAA,EAEA,QACE,SAKA;AACA,UAAM,SAAS,QAAQ;AACvB,QAAI,KAAK,MAAM,IAAI,MAAM,GAAG;AAC1B,YAAM,IAAI,MAAM,gBAAgB,MAAM,iBAAiB;AAAA,IACzD;AACA,UAAM,OAAO,IAAI,KAAK,OAAO;AAC7B,SAAK,MAAM,IAAI,QAAQ,IAAI;AAE3B,eAAW,SAAS,QAAQ,gBAAgB,CAAC,GAAG;AAC9C,UAAI,OAAO,UAAU,SAAU,OAAM,IAAI,MAAM,gCAAgC;AAC/E,YAAM,gBAAgB,KAAK,MAAM,IAAI,KAAK;AAC1C,UAAI,CAAC,cAAe,OAAM,IAAI,MAAM,cAAc,KAAK,uBAAuB,MAAM,EAAE;AACtF,WAAK,cAAc,KAAK;AAAA,IAC1B;AAEA,WAAO;AAAA,EAKT;AAAA,EAEQ,kBAAkB;AACxB,UAAM,UAAU,oBAAI,IAAY;AAChC,UAAM,OAAO,oBAAI,IAAY;AAE7B,UAAM,QAAQ,CAAC,WAAmB;AAChC,UAAI,KAAK,IAAI,MAAM,GAAG;AACpB,cAAM,IAAI,MAAM,+CAA+C,MAAM,EAAE;AAAA,MACzE;AACA,UAAI,CAAC,QAAQ,IAAI,MAAM,GAAG;AACxB,aAAK,IAAI,MAAM;AACf,cAAM,OAAO,KAAK,MAAM,IAAI,MAAM;AAClC,YAAI,CAAC,KAAM,OAAM,IAAI,MAAM,QAAQ,MAAM,YAAY;AAErD,mBAAW,SAAS,KAAK,cAAc;AACrC,gBAAM,KAAK;AAAA,QACb;AAEA,aAAK,OAAO,MAAM;AAClB,gBAAQ,IAAI,MAAM;AAClB,aAAK,MAAM,KAAK,MAAM;AAAA,MACxB;AAAA,IACF;AAEA,eAAW,UAAU,KAAK,MAAM,KAAK,GAAG;AACtC,UAAI,CAAC,QAAQ,IAAI,MAAM,GAAG;AACxB,cAAM,MAAM;AAAA,MACd;AAAA,IACF;AAAA,EACF;AACF;;;ADrKO,IAAM,QAAN,MAEP;AAAA,EAIE,YACkB,IACC,MACA,aACA,gBACjB,cACA,uBACA;AANgB;AACC;AACA;AACA;AANnB,SAAQ,aAAa;AAUnB,SAAK,mBAAmB,IAAI,iBAA0C,EACnE,gBAAgB,YAAY,EAC5B,kBAAkB,qBAAqB,EACvC,cAAc;AAAA,EACnB;AAAA,EAEA,QAAgD,OAuB9C;AACA,QAAI,KAAK,WAAY,OAAM,IAAI,MAAM,gDAAgD;AACrF,SAAK,iBAAiB,QAAQ;AAAA,MAC5B,IAAI,MAAM;AAAA,MACV,SAAS,MAAM;AAAA,MACf,cAAc,MAAM;AAAA,MACpB,aAAa,MAAM,eAAe,KAAK;AAAA,MACvC,cAAc,MAAM;AAAA,IACtB,CAAC;AACD,WAAO;AAAA,EAWT;AAAA,EAEA,MAAM,SAA6E;AACjF,QAAI,KAAK,WAAY,OAAM,IAAI,MAAM,qDAAqD;AAC1F,QAAI,CAAC,KAAK,iBAAiB,KAAM,OAAM,IAAI,MAAM,2CAA2C;AAE5F,UAAM,WAAW,KAAK,iBAAiB,MAAM,EAAE;AAC/C,UAAM,QAAQ,SAAS;AAEvB,UAAM,mCAAmC,YAAY;AACnD,YAAM,eAAe,MAAM,SAAS;AACpC,UAAI,SAAS,kBAAmB,OAAM,QAAQ,kBAAkB,YAAY;AAAA,IAC9E;AAEA,UAAM,UAAU,YAAY;AAC1B,UAAI;AACF,YAAI,CAAC,OAAO;AACV,gBAAM,iCAAiC;AAAA,QACzC,OAAO;AACL,sBAAY,OAAO,MAAM,KAAK,WAAW,OAAO,SAAS,OAAO;AAChE,cAAI,MAAM;AACR,kBAAM,iCAAiC;AAAA,UACzC;AAAA,QACF;AAAA,MACF,SAAS,OAAO;AACd,gBAAQ,MAAM,SAAS,KAAK,EAAE,YAAY,KAAK,EAAE;AAAA,MACnD;AAAA,IACF;AACA,SAAK,KAAK,MAAM,OAAO;AACvB,SAAK,aAAa;AAClB,QAAI,KAAK,eAAgB,MAAK,QAAQ;AACtC,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,OAAsB;AAC1B,QAAI,CAAC,KAAK,WAAY,OAAM,IAAI,MAAM,gDAAgD;AACtF,UAAM,KAAK,KAAK,KAAK;AAAA,EACvB;AAAA,EAEA,MAAM,UAAyB;AAC7B,QAAI,CAAC,KAAK,WAAY,OAAM,IAAI,MAAM,mDAAmD;AACzF,UAAM,KAAK,KAAK,QAAQ;AAAA,EAC1B;AAAA,EAEA,MAAc,WAAW,OAAc,aAA6D;AAClG,UAAM,QAAQ,IAAI,MAAM,OAAO,KAAK,IAAI,WAAW;AACnD,UAAM,OAAO,MAAM,MAAM,WAAW;AACpC,QAAI,CAAC,KAAM,QAAO;AAClB,WAAO;AAAA,MACL;AAAA,MACA,CAAC,OAAO,YAAY,GAAG,YAAY;AACjC,YAAI;AACF,gBAAM,MAAM,QAAQ;AAAA,QACtB,SAAS,OAAO;AACd,kBAAQ,MAAM,kCAAkC,KAAK,EAAE,KAAK,KAAK,EAAE;AAAA,QACrE;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;;;AIjIA,OAAO,YAAkC;AAGlC,IAAM,OAAN,MAA4B;AAAA,EAGjC,YACmB,gBACA,aACjB;AAFiB;AACA;AAJnB,SAAQ,MAAqB;AAAA,EAK1B;AAAA,EAEH,MAAM,SAA2C;AAC/C,QAAI,KAAK,IAAK,OAAM,IAAI,MAAM,4CAA4C;AAC1E,SAAK,MAAM,IAAI,OAAO,KAAK,gBAAgB,KAAK,aAAa,OAAO;AAAA,EACtE;AAAA,EAEA,OAAsB;AACpB,WAAO,IAAI,QAAc,CAAC,YAAY;AACpC,YAAM,eAAe,MAAM;AACzB,YAAI,KAAK,KAAK,OAAO,EAAG,YAAW,cAAc,GAAG;AAAA,aAC/C;AACH,eAAK,KAAK,KAAK;AACf,kBAAQ;AAAA,QACV;AAAA,MACF;AACA,mBAAa;AAAA,IACf,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,UAAyB;AAC7B,QAAI,CAAC,KAAK,IAAK,OAAM,IAAI,MAAM,yCAAyC;AACxE,UAAM,KAAK,IAAI,QAAQ;AAAA,EACzB;AACF;;;ACFO,IAAM,eAAN,MAA0C;AAAA,EAChD,YAA6B,IAAY;AAAZ;AAAA,EAAa;AAAA,EAE1C,YACC,SACA,SAC8C;AAE9C,UAAM,OAAO,IAAI,KAAK,SAAS,OAAO;AACtC,WAAO,IAAI,mBAAmB,KAAK,IAAI,IAAI;AAAA,EAC5C;AACD;AAEA,IAAM,qBAAN,MAEA;AAAA,EASC,YACkB,IACA,MAChB;AAFgB;AACA;AATlB;AAAA,SAAQ,cAA2B,EAAE,YAAY,GAAG,cAAc,EAAE;AAEpE;AAAA,SAAQ,iBAAiB;AAEzB;AAAA,SAAQ,wBAAiC;AAAA,EAMtC;AAAA;AAAA,EAGH,QAA6C;AAE5C,WAAO,IAAI;AAAA,MACV,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,IAIN;AAAA,EACD;AAAA,EAEA,eAAuD;AACtD,SAAK,iBAAiB;AACtB,WAAO;AAAA,EACR;AAAA,EAEA,gBACC,MACoC;AACpC,SAAK,eAAe;AACpB,WAAO;AAAA,EACR;AAAA,EAEA,kBACC,gBACyD;AACzD,SAAK,wBAAwB;AAC7B,WAAO;AAAA,EAIR;AAAA,EAEA,eAAe,QAA6D;AAC3E,SAAK,cAAc;AACnB,WAAO;AAAA,EACR;AACD;;;AClGO,IAAM,YAAN,MAAgB;AAAA,EAAhB;AAEL;AAAA,SAAiB,OAAgG,CAAC;AAAA;AAAA,EAElH,OAAgC,OAI7B;AACD,SAAK,KAAK,KAAK,KAAK;AAAA,EACtB;AAAA,EAEA,MAAM,OAAe;AACnB,eAAW,EAAE,IAAI,KAAK,KAAK,MAAM;AAC/B,UAAI,MAAM,EAAE,MAAM,CAAC;AAAA,IACrB;AAAA,EACF;AAAA,EAEA,MAAM,OAAO;AACX,UAAM,QAAQ,IAAI,KAAK,KAAK,IAAI,CAAC,EAAE,IAAI,MAAM,IAAI,KAAK,CAAC,CAAC;AAAA,EAC1D;AACF;","names":["error"]}