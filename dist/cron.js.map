{"version":3,"sources":["../src/cron.ts"],"sourcesContent":["import Croner, { type CronOptions } from \"croner\";\nimport type { ICron } from \"./cron.types\";\n\nexport class Cron implements ICron {\n  private job: Croner | null = null;\n\n  constructor(\n    private readonly cronExpression: string,\n    private readonly cronOptions?: CronOptions,\n  ) {}\n\n  start(handler: () => Promise<void> | void): void {\n    if (this.job) throw new Error(\"Attempting to start an already started job\");\n    this.job = new Croner(this.cronExpression, this.cronOptions, handler);\n  }\n\n  stop(): Promise<void> {\n    return new Promise<void>((resolve) => {\n      const checkAndStop = () => {\n        if (this.job?.isBusy()) setTimeout(checkAndStop, 100);\n        else {\n          this.job?.stop();\n          resolve();\n        }\n      };\n      checkAndStop();\n    });\n  }\n\n  async trigger(): Promise<void> {\n    if (!this.job) throw new Error(\"Attempting to trigger a non-started job\");\n    await this.job.trigger();\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAAyC;AAGlC,IAAM,OAAN,MAA4B;AAAA,EAGjC,YACmB,gBACA,aACjB;AAFiB;AACA;AAJnB,SAAQ,MAAqB;AAAA,EAK1B;AAAA,EAEH,MAAM,SAA2C;AAC/C,QAAI,KAAK,IAAK,OAAM,IAAI,MAAM,4CAA4C;AAC1E,SAAK,MAAM,IAAI,cAAAA,QAAO,KAAK,gBAAgB,KAAK,aAAa,OAAO;AAAA,EACtE;AAAA,EAEA,OAAsB;AACpB,WAAO,IAAI,QAAc,CAAC,YAAY;AACpC,YAAM,eAAe,MAAM;AACzB,YAAI,KAAK,KAAK,OAAO,EAAG,YAAW,cAAc,GAAG;AAAA,aAC/C;AACH,eAAK,KAAK,KAAK;AACf,kBAAQ;AAAA,QACV;AAAA,MACF;AACA,mBAAa;AAAA,IACf,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,UAAyB;AAC7B,QAAI,CAAC,KAAK,IAAK,OAAM,IAAI,MAAM,yCAAyC;AACxE,UAAM,KAAK,IAAI,QAAQ;AAAA,EACzB;AACF;","names":["Croner"]}