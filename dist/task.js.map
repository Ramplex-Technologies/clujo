{"version":3,"sources":["../src/task.ts"],"sourcesContent":["/* --------------------------------------------------------------------------\n\n  MIT License\n\n  Copyright (c) 2024 Rami Pellumbi\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n-----------------------------------------------------------------------------*/\n\nimport { promisify } from \"node:util\";\n\nexport type TaskOptions<\n  TTaskId extends string,\n  TTaskDependencies extends Record<string, unknown>,\n  TTaskContext extends Record<string, unknown> & { initial: unknown },\n  TTaskReturn,\n  TPossibleTaskDependencyId extends string = never,\n  TInput = { deps: TTaskDependencies; ctx: TTaskContext },\n> = {\n  id: TTaskId;\n  dependencies?: TPossibleTaskDependencyId[];\n  retryPolicy?: RetryPolicy;\n  execute: (input: TInput) => Promise<TTaskReturn> | TTaskReturn;\n  errorHandler?: (err: Error, input: TInput) => Promise<void> | void;\n};\n\n/**\n * Represents a task that can be executed. A task takes a set of dependencies and a context as input,\n * and returns a (potentially void) value when executed.\n *\n * @template TTaskDependencies - Type of task dependencies\n * @template TTaskContext - Type of task context\n * @template TTaskReturn - Type of task return value\n */\nexport class Task<\n  TTaskDependencies extends Record<string, unknown>,\n  TTaskContext extends Record<string, unknown> & { initial: unknown },\n  TTaskReturn,\n> {\n  private readonly _dependencies: string[] = [];\n\n  private _retryPolicy: RetryPolicy = { maxRetries: 0, retryDelayMs: 0 };\n  private _status: TaskStatus = \"pending\";\n\n  constructor(private readonly options: TaskOptions<string, TTaskDependencies, TTaskContext, TTaskReturn, string>) {\n    if (options.retryPolicy) {\n      this._validateRetryPolicy(options.retryPolicy);\n      this._retryPolicy = options.retryPolicy;\n    }\n  }\n\n  /**\n   * Adds a dependency to the task.\n   *\n   * @param taskId - The ID of the task to add as a dependency\n   */\n  public addDependency(taskId: string): void {\n    if (taskId === this.options.id) throw new Error(\"A task cannot depend on itself\");\n    this._dependencies.push(taskId);\n  }\n\n  /**\n   * Gets the list of task dependencies.\n   *\n   * @returns An array of task IDs representing the dependencies\n   */\n  public get dependencies(): string[] {\n    return this._dependencies;\n  }\n\n  /**\n   * Gets the ID of the task.\n   *\n   * @returns The task ID\n   */\n  public get id(): string {\n    return this.options.id;\n  }\n\n  /**\n   * Executes the task with the given dependencies and context, retrying if necessary\n   * up to the maximum number of retries specified in the retry policy. Each retry\n   * is separated by the retry delay (in ms) specified in the retry policy.\n   *\n   * @param {TTaskDependencies} deps - The task dependencies\n   * @param {TTaskContext} ctx - The task context\n   * @returns {Promise<TTaskReturn>} A promise that resolves with the task result\n   * @throws {Error} If the task execution fails after all retry attempts\n   */\n  public async run(deps: TTaskDependencies, ctx: TTaskContext): Promise<TTaskReturn> {\n    // we retry maxRetries times on top of the initial attempt\n    for (let attempt = 0; attempt < this._retryPolicy.maxRetries + 1; attempt++) {\n      try {\n        this._status = \"running\";\n        const result = await this.options.execute({ deps, ctx });\n        this._status = \"completed\";\n        return result;\n      } catch (err) {\n        if (attempt === this._retryPolicy.maxRetries) {\n          console.error(`Task failed after ${attempt + 1} attempts: ${err}`);\n          const error = err instanceof Error ? err : new Error(`Non error throw: ${String(err)}`);\n          try {\n            if (this.options.errorHandler) await this.options.errorHandler(error, { deps, ctx });\n            else console.error(`Error in task ${this.options.id}: ${err}`);\n          } catch (error) {\n            console.error(`Error in task error handler for ${this.options.id}: ${error}`);\n          }\n          this._status = \"failed\";\n          throw error;\n        }\n        console.error(`Task failed, retrying (attempt ${attempt + 1}/${this._retryPolicy.maxRetries}): ${err}`);\n        await sleep(this._retryPolicy.retryDelayMs);\n      }\n    }\n\n    // This line should never be reached due to the for loop condition,\n    // but TypeScript requires a return statement here\n    throw new Error(\"Unexpected end of run method\");\n  }\n\n  /**\n   * Gets the status of the task.\n   *\n   * @returns The current status of the task\n   */\n  public get status() {\n    return this._status;\n  }\n\n  private _validateRetryPolicy(retryPolicy: RetryPolicy) {\n    const { maxRetries, retryDelayMs } = retryPolicy;\n    if (typeof maxRetries !== \"number\" || maxRetries < 0 || !Number.isInteger(maxRetries)) {\n      throw new Error(\"maxRetries must be a non-negative integer\");\n    }\n    if (typeof retryDelayMs !== \"number\" || retryDelayMs < 0) {\n      throw new Error(\"retryDelayMs must be a non-negative number\");\n    }\n  }\n}\n\nconst sleep = promisify(setTimeout);\n\n/**\n * Defines the retry policy for a task.\n */\ntype RetryPolicy = {\n  /**\n   * The maximum number of retry attempts.\n   */\n  maxRetries: number;\n  /**\n   * The delay in milliseconds between retry attempts.\n   */\n  retryDelayMs: number;\n};\n\n/**\n * Represents the possible states of a task.\n *\n * - pending: Task is pending execution start\n * - running: Task is executing\n * - completed: Task has been executed successfully\n * - failed: Task has failed to execute\n */\ntype TaskStatus = \"pending\" | \"running\" | \"completed\" | \"failed\";\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAyBA,uBAA0B;AAyBnB,IAAM,OAAN,MAIL;AAAA,EAMA,YAA6B,SAAoF;AAApF;AAC3B,QAAI,QAAQ,aAAa;AACvB,WAAK,qBAAqB,QAAQ,WAAW;AAC7C,WAAK,eAAe,QAAQ;AAAA,IAC9B;AAAA,EACF;AAAA,EAViB,gBAA0B,CAAC;AAAA,EAEpC,eAA4B,EAAE,YAAY,GAAG,cAAc,EAAE;AAAA,EAC7D,UAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcvB,cAAc,QAAsB;AACzC,QAAI,WAAW,KAAK,QAAQ,GAAI,OAAM,IAAI,MAAM,gCAAgC;AAChF,SAAK,cAAc,KAAK,MAAM;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAW,eAAyB;AAClC,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAW,KAAa;AACtB,WAAO,KAAK,QAAQ;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,MAAa,IAAI,MAAyB,KAAyC;AAEjF,aAAS,UAAU,GAAG,UAAU,KAAK,aAAa,aAAa,GAAG,WAAW;AAC3E,UAAI;AACF,aAAK,UAAU;AACf,cAAM,SAAS,MAAM,KAAK,QAAQ,QAAQ,EAAE,MAAM,IAAI,CAAC;AACvD,aAAK,UAAU;AACf,eAAO;AAAA,MACT,SAAS,KAAK;AACZ,YAAI,YAAY,KAAK,aAAa,YAAY;AAC5C,kBAAQ,MAAM,qBAAqB,UAAU,CAAC,cAAc,GAAG,EAAE;AACjE,gBAAM,QAAQ,eAAe,QAAQ,MAAM,IAAI,MAAM,oBAAoB,OAAO,GAAG,CAAC,EAAE;AACtF,cAAI;AACF,gBAAI,KAAK,QAAQ,aAAc,OAAM,KAAK,QAAQ,aAAa,OAAO,EAAE,MAAM,IAAI,CAAC;AAAA,gBAC9E,SAAQ,MAAM,iBAAiB,KAAK,QAAQ,EAAE,KAAK,GAAG,EAAE;AAAA,UAC/D,SAASA,QAAO;AACd,oBAAQ,MAAM,mCAAmC,KAAK,QAAQ,EAAE,KAAKA,MAAK,EAAE;AAAA,UAC9E;AACA,eAAK,UAAU;AACf,gBAAM;AAAA,QACR;AACA,gBAAQ,MAAM,kCAAkC,UAAU,CAAC,IAAI,KAAK,aAAa,UAAU,MAAM,GAAG,EAAE;AACtG,cAAM,MAAM,KAAK,aAAa,YAAY;AAAA,MAC5C;AAAA,IACF;AAIA,UAAM,IAAI,MAAM,8BAA8B;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAW,SAAS;AAClB,WAAO,KAAK;AAAA,EACd;AAAA,EAEQ,qBAAqB,aAA0B;AACrD,UAAM,EAAE,YAAY,aAAa,IAAI;AACrC,QAAI,OAAO,eAAe,YAAY,aAAa,KAAK,CAAC,OAAO,UAAU,UAAU,GAAG;AACrF,YAAM,IAAI,MAAM,2CAA2C;AAAA,IAC7D;AACA,QAAI,OAAO,iBAAiB,YAAY,eAAe,GAAG;AACxD,YAAM,IAAI,MAAM,4CAA4C;AAAA,IAC9D;AAAA,EACF;AACF;AAEA,IAAM,YAAQ,4BAAU,UAAU;","names":["error"]}