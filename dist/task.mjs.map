{"version":3,"sources":["../src/task.ts"],"sourcesContent":["import { promisify } from \"node:util\";\n\nconst sleep = promisify(setTimeout);\n\nexport type TaskOptions<\n  TTaskId extends string,\n  TTaskDependencies extends Record<string, unknown>,\n  TTaskContext extends Record<string, unknown> & { initial: unknown },\n  TTaskReturn,\n  TPossibleTaskDependencyId extends string = never,\n  TInput = { deps: TTaskDependencies; ctx: TTaskContext },\n> = {\n  id: TTaskId;\n  dependencies?: TPossibleTaskDependencyId[];\n  retryPolicy?: RetryPolicy;\n  execute: (input: TInput) => Promise<TTaskReturn> | TTaskReturn;\n  errorHandler?: (err: Error, input: TInput) => Promise<void> | void;\n};\n\nexport class Task<\n  TTaskDependencies extends Record<string, unknown>,\n  TTaskContext extends Record<string, unknown> & { initial: unknown },\n  TTaskReturn,\n  TPossibleTaskId,\n> {\n  private readonly _dependencies: TPossibleTaskId[] = [];\n\n  private _retryPolicy: RetryPolicy = { maxRetries: 0, retryDelayMs: 0 };\n  private _status: TaskStatus = \"pending\";\n\n  constructor(private readonly options: TaskOptions<string, TTaskDependencies, TTaskContext, TTaskReturn, string>) {\n    if (options.retryPolicy) {\n      this._validateRetryPolicy(options.retryPolicy);\n      this._retryPolicy = options.retryPolicy;\n    }\n  }\n\n  public addDependency(taskId: TPossibleTaskId) {\n    this._dependencies.push(taskId);\n  }\n\n  public get dependencies() {\n    return this._dependencies;\n  }\n\n  public get id() {\n    return this.options.id;\n  }\n\n  public async run(deps: TTaskDependencies, ctx: TTaskContext): Promise<TTaskReturn> {\n    // we retry maxRetries times on top of the initial attempt\n    for (let attempt = 0; attempt < this._retryPolicy.maxRetries + 1; attempt++) {\n      try {\n        this._status = \"running\";\n        const result = await this.options.execute({ deps, ctx });\n        this._status = \"completed\";\n        return result;\n      } catch (err) {\n        if (attempt === this._retryPolicy.maxRetries) {\n          console.error(`Task failed after ${attempt + 1} attempts: ${err}`);\n          const error = err instanceof Error ? err : new Error(`Non error throw: ${String(err)}`);\n          try {\n            if (this.options.errorHandler) await this.options.errorHandler(error, { deps, ctx });\n            else console.error(`Error in task ${this.options.id}: ${err}`);\n          } catch (error) {\n            console.error(`Error in task error handler for ${this.options.id}: ${error}`);\n          }\n          this._status = \"failed\";\n          throw error;\n        }\n        console.error(`Task failed, retrying (attempt ${attempt + 1}/${this._retryPolicy.maxRetries}): ${err}`);\n        await sleep(this._retryPolicy.retryDelayMs);\n      }\n    }\n\n    // This line should never be reached due to the for loop condition,\n    // but TypeScript requires a return statement here\n    throw new Error(\"Unexpected end of run method\");\n  }\n\n  public get status() {\n    return this._status;\n  }\n\n  private _validateRetryPolicy(retryPolicy: RetryPolicy) {\n    const { maxRetries, retryDelayMs } = retryPolicy;\n    if (typeof maxRetries !== \"number\" || maxRetries < 0 || !Number.isInteger(maxRetries)) {\n      throw new Error(\"maxRetries must be a non-negative integer\");\n    }\n    if (typeof retryDelayMs !== \"number\" || retryDelayMs < 0) {\n      throw new Error(\"retryDelayMs must be a non-negative number\");\n    }\n  }\n}\n\ntype TaskStatus = \"pending\" | \"completed\" | \"failed\" | \"running\";\n\ntype RetryPolicy = {\n  maxRetries: number;\n  retryDelayMs: number;\n};\n"],"mappings":";AAAA,SAAS,iBAAiB;AAE1B,IAAM,QAAQ,UAAU,UAAU;AAiB3B,IAAM,OAAN,MAKL;AAAA,EAMA,YAA6B,SAAoF;AAApF;AAC3B,QAAI,QAAQ,aAAa;AACvB,WAAK,qBAAqB,QAAQ,WAAW;AAC7C,WAAK,eAAe,QAAQ;AAAA,IAC9B;AAAA,EACF;AAAA,EAViB,gBAAmC,CAAC;AAAA,EAE7C,eAA4B,EAAE,YAAY,GAAG,cAAc,EAAE;AAAA,EAC7D,UAAsB;AAAA,EASvB,cAAc,QAAyB;AAC5C,SAAK,cAAc,KAAK,MAAM;AAAA,EAChC;AAAA,EAEA,IAAW,eAAe;AACxB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAW,KAAK;AACd,WAAO,KAAK,QAAQ;AAAA,EACtB;AAAA,EAEA,MAAa,IAAI,MAAyB,KAAyC;AAEjF,aAAS,UAAU,GAAG,UAAU,KAAK,aAAa,aAAa,GAAG,WAAW;AAC3E,UAAI;AACF,aAAK,UAAU;AACf,cAAM,SAAS,MAAM,KAAK,QAAQ,QAAQ,EAAE,MAAM,IAAI,CAAC;AACvD,aAAK,UAAU;AACf,eAAO;AAAA,MACT,SAAS,KAAK;AACZ,YAAI,YAAY,KAAK,aAAa,YAAY;AAC5C,kBAAQ,MAAM,qBAAqB,UAAU,CAAC,cAAc,GAAG,EAAE;AACjE,gBAAM,QAAQ,eAAe,QAAQ,MAAM,IAAI,MAAM,oBAAoB,OAAO,GAAG,CAAC,EAAE;AACtF,cAAI;AACF,gBAAI,KAAK,QAAQ,aAAc,OAAM,KAAK,QAAQ,aAAa,OAAO,EAAE,MAAM,IAAI,CAAC;AAAA,gBAC9E,SAAQ,MAAM,iBAAiB,KAAK,QAAQ,EAAE,KAAK,GAAG,EAAE;AAAA,UAC/D,SAASA,QAAO;AACd,oBAAQ,MAAM,mCAAmC,KAAK,QAAQ,EAAE,KAAKA,MAAK,EAAE;AAAA,UAC9E;AACA,eAAK,UAAU;AACf,gBAAM;AAAA,QACR;AACA,gBAAQ,MAAM,kCAAkC,UAAU,CAAC,IAAI,KAAK,aAAa,UAAU,MAAM,GAAG,EAAE;AACtG,cAAM,MAAM,KAAK,aAAa,YAAY;AAAA,MAC5C;AAAA,IACF;AAIA,UAAM,IAAI,MAAM,8BAA8B;AAAA,EAChD;AAAA,EAEA,IAAW,SAAS;AAClB,WAAO,KAAK;AAAA,EACd;AAAA,EAEQ,qBAAqB,aAA0B;AACrD,UAAM,EAAE,YAAY,aAAa,IAAI;AACrC,QAAI,OAAO,eAAe,YAAY,aAAa,KAAK,CAAC,OAAO,UAAU,UAAU,GAAG;AACrF,YAAM,IAAI,MAAM,2CAA2C;AAAA,IAC7D;AACA,QAAI,OAAO,iBAAiB,YAAY,eAAe,GAAG;AACxD,YAAM,IAAI,MAAM,4CAA4C;AAAA,IAC9D;AAAA,EACF;AACF;","names":["error"]}