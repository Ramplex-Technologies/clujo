{"version":3,"sources":["../src/index.ts","../src/clujo.ts","../src/_cron.ts","../src/error.ts","../src/scheduler.ts","../src/_context.ts","../src/_dependency-map.ts","../src/_task.ts","../src/task-graph.ts"],"sourcesContent":["/* --------------------------------------------------------------------------\n\n  Exports make use of the following third-party libraries:\n\n  croner - MIT License - Hexagon <hexagon@56k.guru>\n  ioredis - MIT License - Zihua Li\n  redis-semaphore - MIT License - Alexander Mochalin\n\n  ---------------------------------------------------------------------------\n\n  MIT License\n\n  Copyright (c) 2024 Rami Pellumbi\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n-----------------------------------------------------------------------------*/\n\nimport { Clujo } from \"./clujo\";\nimport { TaskError } from \"./error\";\nimport { Scheduler } from \"./scheduler\";\nimport { TaskGraph } from \"./task-graph\";\n\nexport { Clujo, Scheduler, TaskError, TaskGraph };\nexport default {\n    Clujo,\n    Scheduler,\n    TaskError,\n    TaskGraph,\n};\n","/* --------------------------------------------------------------------------\n\n  croner - MIT License - Hexagon <hexagon@56k.guru>\n  ioredis - MIT License - Zihua Li\n  redis-semaphore - MIT License - Alexander Mochalin\n\n  ---------------------------------------------------------------------------\n\n  MIT License\n\n  Copyright (c) 2024 Rami Pellumbi\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n-----------------------------------------------------------------------------*/\n\nimport type { CronOptions } from \"croner\";\nimport type { Redis } from \"ioredis\";\nimport { type LockOptions, Mutex } from \"redis-semaphore\";\nimport { Cron } from \"./_cron\";\nimport type { TaskGraphRunner } from \"./task-graph\";\n\n/**\n * Represents a Clujo instance, which is a cron job that executes a task graph.\n *\n * @template TTaskDependencies - Type of the dependencies each task will receive\n * @template TTaskContext - Type of the context each task will receive\n\n * @param input The input to the Clujo constructor.\n * @param input.id The unique identifier for the Clujo instance.\n * @param input.taskGraphRunner The task graph runner to use for executing the task graph.\n * @param input.cron The cron schedule for the Clujo instance.\n * @param input.cron.pattern The cron pattern to use for scheduling the task graph. If a Date object is provided, the task graph will execute once at the specified time.\n * @param input.cron.options Optional options to use when creating the cron job.\n * @param input.redis The redis settings for distributed locking\n * @param input.redis.client The IORedis client instance\n * @param input.redis.lockOptions The redis-semaphore lock options for lock acquisition\n * @param input.runOnStartup If `true`, executes the task graph immediately on start, independent of the cron schedule\n *\n * @throw An error if the Clujo ID, task graph runner, or cron pattern is not provided.\n *\n * @example\n * const clujo = new Clujo({\n *   id: 'my-clujo-instance',\n *   taskGraphRunner: myTaskGraphRunner,\n *   cron: {\n *     pattern: '0 0 * * *', // Run daily at midnight\n *     options: { timezone: 'America/New_York' }\n *   },\n *   runOnStartup: false,\n *   redis: { client: myRedisClient }\n * });\n */\nexport class Clujo<\n    TTaskDependencies extends Record<string, unknown> = Record<string, unknown>,\n    TTaskContext extends Record<string, unknown> & {\n        initial: unknown;\n    } = Record<string, unknown> & { initial: unknown },\n> {\n    readonly #id: string;\n    readonly #cron: Cron;\n    readonly #taskGraphRunner: TaskGraphRunner<TTaskDependencies, TTaskContext[\"initial\"], TTaskContext>;\n    readonly #redis?: { client: Redis; lockOptions?: LockOptions };\n    readonly #enabled: boolean;\n    readonly #logger?: ClujoLogger;\n\n    #hasStarted = false;\n    #runOnStartup = false;\n\n    constructor({\n        id,\n        taskGraphRunner,\n        cron,\n        enabled,\n        runOnStartup,\n        redis,\n        logger,\n    }: {\n        id: string;\n        taskGraphRunner: TaskGraphRunner<TTaskDependencies, TTaskContext[\"initial\"], TTaskContext>;\n        cron: ({ pattern: string | Date } | { patterns: (string | Date)[] }) & { options?: CronOptions };\n        enabled?: boolean;\n        runOnStartup?: boolean;\n        redis?: { client: Redis; lockOptions?: LockOptions };\n        logger?: ClujoLogger;\n    }) {\n        logger?.debug?.(`Initializing Clujo instance with ID: ${id}`);\n        if (!id) {\n            throw new Error(\"Clujo ID is required.\");\n        }\n        if (!taskGraphRunner) {\n            throw new Error(\"taskGraphRunner is required\");\n        }\n        if (!(\"pattern\" in cron || \"patterns\" in cron)) {\n            throw new Error(\"Either cron.pattern or cron.patterns is required.\");\n        }\n        if (\"pattern\" in cron && !cron.pattern) {\n            throw new Error(\"cron.pattern is required\");\n        }\n        if (\"patterns\" in cron && !cron.patterns) {\n            throw new Error(\"cron.patterns is required\");\n        }\n        if (enabled && typeof enabled !== \"boolean\") {\n            throw new Error(\"enabled must be a boolean\");\n        }\n        if (runOnStartup && typeof runOnStartup !== \"boolean\") {\n            throw new Error(\"runOnStartup must be a boolean.\");\n        }\n        if (redis && !redis.client) {\n            throw new Error(\"Redis client is required in redis input.\");\n        }\n        if (redis) {\n            logger?.debug?.(`Redis configuration provided for Clujo ${id}`);\n        }\n        if (enabled === false) {\n            logger?.log?.(`Clujo instance ${id} initialized in disabled state`);\n        }\n        if (runOnStartup) {\n            logger?.debug?.(`Clujo ${id} configured to run on startup`);\n        }\n        this.#id = id;\n        this.#taskGraphRunner = taskGraphRunner;\n        this.#cron = new Cron(\"pattern\" in cron ? cron.pattern : cron.patterns, cron.options);\n        this.#runOnStartup = Boolean(runOnStartup);\n        // default to enabled\n        this.#enabled = enabled ?? true;\n        this.#redis = redis;\n        this.#logger = logger;\n        logger?.log?.(`Clujo instance ${id} successfully initialized`);\n    }\n\n    get id(): string {\n        return this.#id;\n    }\n\n    /**\n     * Starts the cron job, which will execute the task graph according to the cron schedule.\n     * @throws An error if the Clujo has already started.\n     */\n    start(): void {\n        this.#logger?.debug?.(`Attempting to start Clujo ${this.#id}`);\n        if (this.#hasStarted) {\n            this.#logger?.error?.(`Failed to start Clujo ${this.#id}: already started`);\n            throw new Error(\"Cannot start a Clujo that has already started.\");\n        }\n\n        const handler = async () => {\n            this.#logger?.debug?.(`Cron trigger received for Clujo ${this.#id}`);\n            if (!this.#enabled) {\n                this.#logger?.log?.(`Skipping execution - Clujo ${this.#id} is disabled`);\n                return;\n            }\n            if (!this.#redis) {\n                this.#logger?.debug?.(`Executing task graph for Clujo ${this.#id} without distributed lock`);\n                await this.#taskGraphRunner.trigger();\n                this.#logger?.log?.(`Successfully completed task graph execution for Clujo ${this.#id}`);\n            } else {\n                this.#logger?.debug?.(`Attempting to acquire distributed lock for Clujo ${this.#id}`);\n                await using lock = await this.#tryAcquire(this.#redis.client, this.#redis.lockOptions);\n                if (lock) {\n                    this.#logger?.debug?.(`Executing task graph for Clujo ${this.#id} with distributed lock`);\n                    await this.#taskGraphRunner.trigger();\n                    this.#logger?.log?.(`Successfully completed task graph execution for Clujo ${this.#id}`);\n                } else {\n                    this.#logger?.log?.(`Skipping execution - Could not acquire lock for Clujo ${this.#id}`);\n                }\n            }\n        };\n        this.#cron.start(handler);\n        this.#hasStarted = true;\n        this.#logger?.log?.(`Clujo ${this.#id} started successfully`);\n\n        // we use the cron trigger here so that prevent overlapping is active by default\n        // i.e., if no lock is used, and the trigger is executing, and the schedule time is reached, the scheduled execution will be skipped\n        if (this.#runOnStartup) {\n            void this.#cron.trigger();\n        }\n    }\n\n    /**\n     * Stops the cron job and prevents any further executions of the task graph.\n     * If the task graph is currently executing, it will be allowed to finish for up to the specified timeout.\n     *\n     * @param timeout The maximum time to wait for the task graph to finish executing before stopping the cron.\n     * @returns A promise that resolves when the cron has stopped.\n     * @throws An error if the Clujo has not started.\n     */\n    async stop(timeout = 5000): Promise<void> {\n        this.#logger?.debug?.(`Attempting to stop Clujo ${this.#id} with timeout ${timeout}ms`);\n        if (!this.#hasStarted) {\n            this.#logger?.error?.(`Failed to stop Clujo ${this.#id}: not started`);\n            throw new Error(\"Cannot stop a Clujo that has not started.\");\n        }\n        try {\n            await this.#cron.stop(timeout);\n            this.#logger?.log?.(`Clujo ${this.#id} stopped successfully`);\n        } catch (error) {\n            this.#logger?.error?.(`Failed to stop Clujo ${this.#id}: ${error}`);\n            throw error;\n        }\n    }\n\n    /**\n     * Trigger an execution of the task graph immediately, independent of the cron schedule.\n     * In the event the cron is running, the task graph will still execute.\n     *\n     * @returns The final context of the task graph.\n     */\n    async trigger(): Promise<TTaskContext> {\n        // we do not trigger via the cron here so that we can make use of the result of the task graph\n        this.#logger?.debug?.(`Manual trigger initiated for Clujo ${this.#id}`);\n        try {\n            const result = await this.#taskGraphRunner.trigger();\n            this.#logger?.log?.(`Manual trigger completed successfully for Clujo ${this.#id}`);\n            return result;\n        } catch (error) {\n            this.#logger?.error?.(`Manual trigger failed for Clujo ${this.#id}: ${error}`);\n            throw error;\n        }\n    }\n\n    /**\n     * Tries to acquire a lock from redis-semaphore. If the lock is acquired, the lock will be released when the lock is disposed.\n     *\n     * @param redis The Redis client to use.\n     * @param lockOptions The options to use when acquiring the lock.\n     *\n     * @returns An AsyncDisposable lock if it was acquired, otherwise null.\n     */\n    async #tryAcquire(redis: Redis, lockOptions: LockOptions | undefined): Promise<AsyncDisposableMutex | null> {\n        this.#logger?.debug?.(`Attempting to acquire mutex for Clujo ${this.#id}`);\n        const mutex = new Mutex(redis, this.#id, {\n            acquireAttemptsLimit: 1,\n            lockTimeout: 30000,\n            refreshInterval: 24000,\n            onLockLost: (lockLostError) => {\n                this.#logger?.error?.(`Lock lost for Clujo ${this.#id}: ${lockLostError.message}`);\n                throw lockLostError;\n            },\n            ...lockOptions,\n        });\n\n        try {\n            const lock = await mutex.tryAcquire();\n            if (!lock) {\n                this.#logger?.debug?.(\n                    `Could not acquire mutex for Clujo ${this.#id} - another instance is likely running`,\n                );\n                return null;\n            }\n            this.#logger?.debug?.(`Successfully acquired mutex for Clujo ${this.#id}`);\n            return {\n                mutex,\n                [Symbol.asyncDispose]: async () => {\n                    try {\n                        await mutex.release();\n                        this.#logger?.debug?.(`Successfully released mutex for Clujo ${this.#id}`);\n                    } catch (error) {\n                        this.#logger?.error?.(`Failed to release mutex for Clujo ${this.#id}: ${error}`);\n                        throw error;\n                    }\n                },\n            };\n        } catch (error) {\n            this.#logger?.error?.(`Failed to acquire mutex for Clujo ${this.#id}: ${error}`);\n            throw error;\n        }\n    }\n}\n\ninterface AsyncDisposableMutex extends AsyncDisposable {\n    mutex: Mutex;\n}\n\ninterface ClujoLogger {\n    log?: (message: string) => void;\n    debug?: (message: string) => void;\n    error?: (message: string) => void;\n}\n","/* --------------------------------------------------------------------------\n\n  croner - MIT License - Hexagon <hexagon@56k.guru>\n\n  ---------------------------------------------------------------------------\n\n  MIT License\n\n  Copyright (c) 2024 Rami Pellumbi\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n-----------------------------------------------------------------------------*/\n\nimport { type CronOptions, Cron as Croner } from \"croner\";\n\nexport class Cron {\n    #jobs: Croner[] | null = null;\n    readonly #cronExpression: string | Date | (string | Date)[];\n    readonly #cronOptions: CronOptions | undefined;\n\n    #isRunning = false;\n\n    constructor(cronExpression: string | Date | (string | Date)[], cronOptions?: CronOptions) {\n        this.#cronExpression = cronExpression;\n        // default to protect mode (prevent overlapping executions) on the same process in the single pattern case\n        this.#cronOptions = { protect: true, ...cronOptions };\n    }\n\n    /**\n     * Starts the cron job with the specified handler.\n     *\n     * @param handler A function to be executed when the cron job triggers.\n     * @throws {Error} If attempting to start a job that has already been started.\n     */\n    start(handler: () => Promise<void> | void): void {\n        if (this.#jobs) {\n            throw new Error(\"Attempting to start an already started job\");\n        }\n        // if using multiple expressions, prevent all from overlapping\n        const wrapHandler = async () => {\n            if (this.#cronOptions?.protect && this.#isRunning) {\n                return;\n            }\n            try {\n                this.#isRunning = true;\n                await handler();\n            } finally {\n                this.#isRunning = false;\n            }\n        };\n        this.#jobs = Array.isArray(this.#cronExpression)\n            ? this.#cronExpression.map((expression) => new Croner(expression, this.#cronOptions, wrapHandler))\n            : [new Croner(this.#cronExpression, this.#cronOptions, handler)];\n    }\n\n    /**\n     * Stops the cron job. If the job is currently running, it will wait for the job to finish before stopping it.\n     * This can be safely invoked even if the job hasn't been started.\n     *\n     * @param timeout The maximum time (in ms) to wait for the job to finish before stopping it forcefully.\n     * @returns A promise that resolves when the job has been stopped\n     */\n    stop(timeout: number): Promise<void> {\n        return new Promise<void>((resolve) => {\n            const startTime = Date.now();\n            const checkAndStop = () => {\n                if (!this.#jobs) {\n                    resolve(); // resolve if job has cleared\n                    return;\n                }\n\n                if (this.#jobs.some((job) => job.isBusy())) {\n                    if (Date.now() - startTime > timeout) {\n                        for (const job of this.#jobs) {\n                            job.stop();\n                            this.#jobs = null;\n                        }\n\n                        resolve();\n                        return;\n                    }\n                    setTimeout(checkAndStop, 100);\n                } else {\n                    for (const job of this.#jobs) {\n                        job.stop();\n                    }\n                    this.#jobs = null;\n                    resolve();\n                    return;\n                }\n            };\n\n            checkAndStop();\n        });\n    }\n\n    /**\n     * Triggers the cron job to run immediately. A triggered execution will prevent the job from running at its scheduled time\n     * unless `protect` is set to `false` in the cron options.\n     *\n     * @throws {Error} If attempting to trigger a job that is not running.\n     */\n    async trigger(): Promise<void> {\n        if (!this.#jobs) {\n            throw new Error(\"Attempting to trigger a job that is not running\");\n        }\n        await this.#jobs[0].trigger();\n    }\n}\n","/* --------------------------------------------------------------------------\n  MIT License\n\n  Copyright (c) 2024 Rami Pellumbi\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n-----------------------------------------------------------------------------*/\n\nexport class TaskError extends Error {\n    public id: string;\n    public error: Error;\n\n    constructor(id: string, error: Error) {\n        super(`Task ${id} failed: ${error.message}`);\n        this.id = id;\n        this.error = error;\n        this.name = \"TaskError\";\n    }\n}\n","/* --------------------------------------------------------------------------\n\n  MIT License\n\n  Copyright (c) 2024 Rami Pellumbi\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n-----------------------------------------------------------------------------*/\n\nimport type { Clujo } from \"./clujo\";\n\n/**\n * Scheduler class for managing and running Clujo jobs.\n * This class allows adding, starting, and stopping multiple Clujo jobs in a centralized manner.\n */\nexport class Scheduler {\n    readonly #jobs: Clujo[] = [];\n\n    /**\n     * Adds a Clujo job to the scheduler.\n     * @param input - Object containing the job and optional completion handler.\n     * @param input.job - The Clujo job to be added.\n     * @param input.completionHandler - Optional function to invoke after the job completes.\n     */\n\n    // biome-ignore lint/suspicious/noExplicitAny: handle any Clujo\n    addJob(job: Clujo<any, any>) {\n        if (this.#jobs.some((addedJob) => addedJob.id === job.id)) {\n            throw new Error(`Job with id ${job.id} is already added to the scheduler.`);\n        }\n        this.#jobs.push(job);\n    }\n\n    /**\n     * Starts all added jobs in the scheduler.\n     *\n     * @param redis - Optional Redis instance to be passed to the jobs. If provided, enables distributed locking.\n     */\n    start() {\n        for (const job of this.#jobs) {\n            job.start();\n        }\n    }\n    /**\n     * Stops all running jobs in the scheduler.\n     *\n     * @param timeout - The maximum time (in milliseconds) to wait for jobs to stop. Defaults to 5000ms.\n     * @returns A promise that resolves when all jobs have stopped or the timeout is reached.\n     */\n    async stop(timeout = 5000) {\n        await Promise.all(this.#jobs.map((job) => job.stop(timeout)));\n    }\n\n    /**\n     * Returns the list of jobs added to the scheduler.\n     */\n    get jobs(): Clujo[] {\n        return this.#jobs;\n    }\n}\n","/* --------------------------------------------------------------------------\n\n  MIT License\n\n  Copyright (c) 2024 Rami Pellumbi\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n-----------------------------------------------------------------------------*/\n\n/**\n * Used to allow for the sharing of state between tasks.\n */\nexport class Context<TInitial, TContext> {\n    #object!: { initial: TInitial | undefined } & TContext;\n    #updateQueue: Promise<void>;\n\n    constructor(initialValue?: TInitial) {\n        this.reset(initialValue);\n        this.#updateQueue = Promise.resolve();\n    }\n\n    /**\n     * Gets the current state of the managed object.\n     */\n    get value(): { initial: TInitial | undefined } & TContext {\n        return this.#object;\n    }\n\n    /**\n     * Resets the context to its initial state or a new initial object.\n     */\n    reset(initialValue: TInitial | undefined): void {\n        if (initialValue !== undefined && initialValue !== null) {\n            this.#object = deepFreeze({ initial: initialValue }) as {\n                initial: TInitial;\n            } & TContext;\n        } else {\n            this.#object = deepFreeze({ initial: undefined }) as {\n                initial: TInitial | undefined;\n            } & TContext;\n        }\n    }\n\n    /**\n     * Asynchronously updates the context with new values. Ensures that updates are applied in the order they are called.\n     */\n    update<NewValue extends object>(updateValue: NewValue): Promise<void> {\n        this.#updateQueue = this.#updateQueue.then(() => {\n            // overrides won't happen with how this is used since\n            // the initial context is under the key \"initial\"\n            // and all task results are under the unique id of that task\n            this.#object = deepFreeze({ ...this.#object, ...updateValue });\n            return Promise.resolve();\n        });\n        return this.#updateQueue;\n    }\n}\n\n// prevent runtime modifications to the context\nfunction deepFreeze<T extends object>(obj: T): Readonly<T> {\n    const propNames = Reflect.ownKeys(obj) as (keyof T)[];\n\n    for (const name of propNames) {\n        const value = obj[name];\n        if (value && typeof value === \"object\" && !Object.isFrozen(value)) {\n            deepFreeze(value);\n        }\n    }\n\n    return Object.freeze(obj);\n}\n","/* --------------------------------------------------------------------------\n  MIT License\n\n  Copyright (c) 2024 Rami Pellumbi\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n-----------------------------------------------------------------------------*/\n\n/**\n * Used to track which other tasks must execute before a task\n */\nexport class DependencyMap {\n    readonly #dependencies: Record<string, string[]> = Object.create(null);\n\n    add(key: string, value: string): void {\n        if (!this.#dependencies[key]) {\n            this.#dependencies[key] = [];\n        }\n        this.#dependencies[key].push(value);\n    }\n\n    get(key: string): readonly string[] {\n        return Object.freeze(this.#dependencies[key]?.slice() ?? []);\n    }\n}\n","/* --------------------------------------------------------------------------\n\n  MIT License\n\n  Copyright (c) 2024 Rami Pellumbi\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n-----------------------------------------------------------------------------*/\n\n// Creates a context type with required dependencies and optional other keys\ntype ContextWithDependencies<TContext extends Record<string, unknown>, TDependencies extends string> = Required<\n    Pick<TContext, TDependencies | \"initial\">\n> &\n    Partial<Omit<TContext, TDependencies | \"initial\">>;\n\nimport { promisify } from \"node:util\";\n\n/**\n * Represents the options for a task.\n *\n * @template TTaskId - string literal type representing the task ID\n * @template TTaskDependencies - Type of task dependencies passed into the task execution function\n * @template TTaskContext - Type of task context passed into the task execution function\n * @template TTaskReturn - Type of task return value\n * @template TPossibleTaskDependencyId - string literal type representing the possible dependencies of this task\n * @template TInput - Type of the input object passed into the task execution function and error handler\n *\n */\nexport type TaskOptions<\n    TTaskId extends string,\n    TTaskDependencies extends Record<string, unknown>,\n    TTaskContext extends Record<string, unknown> & { initial: unknown },\n    TTaskReturn,\n    TPossibleTaskDependencyId extends string = never,\n    TInput = {\n        deps: TTaskDependencies;\n        ctx: [TPossibleTaskDependencyId] extends [never]\n            ? TTaskContext\n            : ContextWithDependencies<TTaskContext, TPossibleTaskDependencyId>;\n    },\n> = {\n    /**\n     * The unique ID of the task.\n     */\n    id: TTaskId;\n    /**\n     * The dependencies of the task.\n     */\n    dependencies?: readonly TPossibleTaskDependencyId[];\n    enabled?: boolean;\n    /**\n     * The retry policy for the task.\n     *\n     * @default { maxRetries: 0, retryDelayMs: 0 }\n     */\n    retryPolicy?: RetryPolicy;\n    /**\n     * The function that executes the task.\n     * This function receives the task dependencies and context as input. It can be synchronous or asynchronous.\n     *\n     * @param input - The input object containing the task dependencies and context\n     * @returns The return value of the task\n     * @throws An error if the task execution fails after all retry attempts\n     */\n    execute: (input: TInput) => Promise<TTaskReturn> | TTaskReturn;\n    /**\n     * An optional error handler for the task.\n     * This function receives an error and the input object as input. It can be synchronous or asynchronous.\n     * When an error handler is provided, it will be invoked when the task execution fails after all retry attempts.\n     * The error will still be thrown after the error handler has been executed.\n     *\n     * @param err - The error that occurred during task execution\n     * @param input - The input object containing the task dependencies and context\n     * @returns A promise that resolves when the error has been handled\n     * @default console.error\n     */\n    errorHandler?: (err: Error, input: TInput) => Promise<void> | void;\n};\n\n/**\n * Represents a task that can be executed. A task takes a set of dependencies and a context as input,\n * and returns a (potentially void) value when executed.\n *\n * @template TTaskDependencies - Type of task dependencies\n * @template TTaskContext - Type of task context\n * @template TTaskReturn - Type of task return value\n */\nexport class Task<\n    TTaskDependencies extends Record<string, unknown>,\n    TTaskContext extends Record<string, unknown> & { initial: unknown },\n    TTaskReturn,\n    TPossibleTaskDependencyId extends string = never,\n> {\n    readonly #options: TaskOptions<string, TTaskDependencies, TTaskContext, TTaskReturn, TPossibleTaskDependencyId>;\n\n    #retryPolicy: RetryPolicy = { maxRetries: 0, retryDelayMs: 0 };\n    #status: TaskStatus = \"pending\";\n\n    constructor(options: TaskOptions<string, TTaskDependencies, TTaskContext, TTaskReturn, TPossibleTaskDependencyId>) {\n        if (options.retryPolicy) {\n            this.#validateRetryPolicy(options.retryPolicy);\n            this.#retryPolicy = options.retryPolicy;\n        }\n        this.#options = options;\n    }\n\n    /**\n     * Return whether this task is enabled or not\n     */\n    get isEnabled(): boolean {\n        return this.#options.enabled === undefined || this.#options.enabled;\n    }\n\n    /**\n     * Gets the ID of the task.\n     *\n     * @returns The task ID\n     */\n    get id(): string {\n        return this.#options.id;\n    }\n\n    /**\n     * Executes the task with the given dependencies and context, retrying if necessary\n     * up to the maximum number of retries specified in the retry policy. Each retry\n     * is separated by the retry delay (in ms) specified in the retry policy.\n     *\n     * @param {TTaskDependencies} deps - The task dependencies\n     * @param {TTaskContext} ctx - The task context\n     * @returns {Promise<TTaskReturn>} A promise that resolves with the task result\n     * @throws {Error} If the task execution fails after all retry attempts\n     */\n    async run(deps: TTaskDependencies, ctx: TTaskContext): Promise<TTaskReturn | null> {\n        if (!this.isEnabled) {\n            this.#status = \"skipped\";\n            return null;\n        }\n        const input = {\n            deps,\n            ctx: ctx as [TPossibleTaskDependencyId] extends [never]\n                ? TTaskContext\n                : ContextWithDependencies<TTaskContext, TPossibleTaskDependencyId>,\n        };\n        // we retry maxRetries times on top of the initial attempt\n        for (let attempt = 0; attempt < this.#retryPolicy.maxRetries + 1; attempt++) {\n            try {\n                this.#status = \"running\";\n                const result = await this.#options.execute(input);\n                this.#status = \"completed\";\n                return result;\n            } catch (err) {\n                if (attempt === this.#retryPolicy.maxRetries) {\n                    console.error(`Task failed after ${attempt + 1} attempts: ${err}`);\n                    const error = err instanceof Error ? err : new Error(`Non error throw: ${String(err)}`);\n                    try {\n                        if (this.#options.errorHandler) {\n                            await this.#options.errorHandler(error, input);\n                        } else {\n                            console.error(`Error in task ${this.#options.id}: ${err}`);\n                        }\n                    } catch (error) {\n                        console.error(`Error in task error handler for ${this.#options.id}: ${error}`);\n                    }\n                    this.#status = \"failed\";\n                    throw error;\n                }\n                console.error(`Task failed, retrying (attempt ${attempt + 1}/${this.#retryPolicy.maxRetries}): ${err}`);\n                await sleep(this.#retryPolicy.retryDelayMs);\n            }\n        }\n\n        // This line should never be reached due to the for loop condition,\n        // but TypeScript requires a return statement here\n        throw new Error(\"Unexpected end of run method\");\n    }\n\n    /**\n     * Gets the status of the task.\n     *\n     * @returns The current status of the task\n     */\n    get status(): TaskStatus {\n        return this.#status;\n    }\n\n    #validateRetryPolicy(retryPolicy: RetryPolicy) {\n        const { maxRetries, retryDelayMs } = retryPolicy;\n        if (typeof maxRetries !== \"number\" || maxRetries < 0 || !Number.isInteger(maxRetries)) {\n            throw new Error(\"maxRetries must be a non-negative integer\");\n        }\n        if (typeof retryDelayMs !== \"number\" || retryDelayMs < 0) {\n            throw new Error(\"retryDelayMs must be a non-negative number\");\n        }\n    }\n}\n\nconst sleep = promisify(setTimeout);\n\n/**\n * Defines the retry policy for a task.\n */\ntype RetryPolicy = {\n    /**\n     * The maximum number of retry attempts.\n     */\n    maxRetries: number;\n    /**\n     * The delay in milliseconds between retry attempts.\n     */\n    retryDelayMs: number;\n};\n\n/**\n * Represents the possible states of a task.\n *\n * - pending: Task is pending execution start\n * - running: Task is executing\n * - completed: Task has been executed successfully\n * - failed: Task has failed to execute\n * - skipped: Task was skipped due to being disabled\n */\ntype TaskStatus = \"pending\" | \"running\" | \"completed\" | \"failed\" | \"skipped\";\n","/* --------------------------------------------------------------------------\n\n  MIT License\n\n  Copyright (c) 2024 Rami Pellumbi\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n-----------------------------------------------------------------------------*/\n\nimport { Context } from \"./_context\";\nimport { DependencyMap } from \"./_dependency-map\";\nimport { Task, type TaskOptions } from \"./_task\";\nimport { TaskError } from \"./error\";\n\ntype DeepReadonly<T> = {\n    readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];\n};\n\n/**\n * Represents a task graph which tasks can be added to\n * When built, the graph will be sorted topologically and returned as a `TaskGraphRunner` instance.\n *\n * @template TTaskDependencies - Type of the dependencies each task will receive\n * @template TInitialTaskContext - Type of the context in the `initial` key that each task will receive\n * @template TTaskContext - Type of the context each task will receive\n * @template TAllDependencyIds - The task IDs that can be used as dependencies for new tasks\n */\nexport class TaskGraph<\n    TTaskDependencies extends Record<string, unknown> = never,\n    TInitialTaskContext = undefined,\n    TTaskContext extends Record<string, unknown> & { readonly initial: DeepReadonly<TInitialTaskContext> } = {\n        readonly initial: DeepReadonly<TInitialTaskContext>;\n    },\n    TAllDependencyIds extends string & keyof TTaskContext = never,\n> {\n    readonly #contextValueOrFactory:\n        | TInitialTaskContext\n        | ((deps: TTaskDependencies) => DeepReadonly<TInitialTaskContext> | Promise<DeepReadonly<TInitialTaskContext>>)\n        | undefined = undefined;\n    readonly #dependencies: TTaskDependencies = Object.create(null);\n    readonly #tasks = new Map<string, Task<TTaskDependencies, TTaskContext, unknown, string>>();\n    readonly #taskDependencies = new DependencyMap();\n    readonly #topologicalOrder: string[] = [];\n\n    constructor(\n        options?:\n            | {\n                  dependencies?: TTaskDependencies;\n                  contextValue?: TInitialTaskContext;\n              }\n            | {\n                  dependencies?: TTaskDependencies;\n                  contextFactory: (deps: TTaskDependencies) => TInitialTaskContext | Promise<TInitialTaskContext>;\n              },\n    ) {\n        // Early return if no options provided\n        if (!options) {\n            return;\n        }\n\n        // Validate dependencies\n        if (\"dependencies\" in options) {\n            if (options.dependencies === undefined) {\n                this.#dependencies = Object.create(null);\n            } else if (!this.#isValidDependencies(options.dependencies)) {\n                throw new Error(\"Dependencies must be a non-null object with defined properties\");\n            } else {\n                this.#dependencies = options.dependencies;\n            }\n        }\n\n        // Validate only one of the context options\n        if (\"contextValue\" in options && \"contextFactory\" in options) {\n            throw new Error(\"Cannot specify both contextValue and contextFactory\");\n        }\n\n        if (\"contextValue\" in options) {\n            if (options.contextValue !== undefined) {\n                if (typeof options.contextValue === \"function\") {\n                    throw new Error(\"Context value must not be a function\");\n                }\n                this.#contextValueOrFactory = options.contextValue;\n            }\n        } else if (\"contextFactory\" in options) {\n            if (typeof options.contextFactory !== \"function\") {\n                throw new Error(\"Context factory must be a function that returns a value or Promise\");\n            }\n            this.#contextValueOrFactory = options.contextFactory;\n        }\n    }\n\n    /**\n     * Adds a new task to the graph.\n     *\n     * @template TTaskId The ID of the task, which must be unique.\n     * @template TTaskDependencyIds The IDs of the task's dependencies.\n     * @template TTaskReturn The return type of the task.\n     * @param options The configuration options for the task:\n     * @param options.id A unique identifier for the task.\n     * @param options.execute A function that performs the task's operation. It receives an object with `deps` (dependencies) and `ctx` (context) properties.\n     * @param options.dependencies An optional array of task IDs that this task depends on. If not provided, the task will be executed immediately on start.\n     * @param options.retryPolicy An optional retry policy for the task, specifying maxRetries and retryDelayMs. Defaults to no retries.\n     * @param options.errorHandler An optional function to handle errors that occur during task execution. Defaults to `console.error`.\n     *\n     * @returns The instance of `TaskGraph` with the new task added for chaining.\n     *\n     * @throws {Error} If a task with the same ID already exists.\n     * @throws {Error} If a specified dependency task has not been added to the graph yet.\n     */\n    addTask<TTaskId extends string, TTaskReturn, TTaskDependencyIds extends TAllDependencyIds = never>(\n        options: TaskOptions<TTaskId, TTaskDependencies, TTaskContext, TTaskReturn, TTaskDependencyIds>,\n    ): TaskGraph<\n        TTaskDependencies,\n        TInitialTaskContext,\n        TTaskContext & { readonly [K in TTaskId]?: TTaskReturn },\n        TAllDependencyIds | TTaskId\n    > {\n        const taskId = options.id;\n        if (this.#tasks.has(taskId)) {\n            throw new Error(`Task with id ${taskId} already exists`);\n        }\n\n        const task = new Task(options);\n        for (const depId of options.dependencies ?? []) {\n            if (typeof depId !== \"string\") {\n                throw new Error(\"Dependency ID must be a string\");\n            }\n            if ((depId as string) === taskId) {\n                throw new Error(`Task ${taskId} cannot depend on itself`);\n            }\n            const dependentTask = this.#tasks.get(depId);\n            if (!dependentTask) {\n                throw new Error(`Dependency ${depId} not found for task ${taskId}`);\n            }\n            this.#taskDependencies.add(taskId, depId);\n        }\n\n        // biome-ignore lint/suspicious/noExplicitAny: the typing here is super annoying\n        this.#tasks.set(taskId, task as any);\n        // biome-ignore lint/suspicious/noExplicitAny: do not want to track the type in two places\n        return this as any;\n    }\n\n    /**\n     * Builds and returns a TaskGraphRunner instance.\n     * This method finalizes the task graph and prepares it for execution by topologically sorting the tasks.\n     * @param options The configuration options for the build\n     * @param options.onTasksCompleted A (sync or async) function to invoke when all tasks have completed\n     * @returns A new `TaskGraphRunner` instance ready to execute the task graph.\n     *\n     * @throws {Error} If no tasks have been added to the graph.\n     */\n    build({\n        onTasksCompleted,\n    }: {\n        onTasksCompleted?: (\n            ctx: DeepReadonly<TTaskContext>,\n            deps: TTaskDependencies,\n            errors: TaskError[] | null,\n        ) => void | Promise<void>;\n    } = {}): TaskGraphRunner<TTaskDependencies, TInitialTaskContext, TTaskContext> {\n        if (!this.size) {\n            throw new Error(\"Unable to build TaskGraphRunner. No tasks added to the graph\");\n        }\n        if (onTasksCompleted && typeof onTasksCompleted !== \"function\") {\n            throw new Error(\"onTasksCompleted must be a function (sync or async).\");\n        }\n        this.#topologicalSort();\n        return new TaskGraphRunner<TTaskDependencies, TInitialTaskContext, TTaskContext>(\n            this.#dependencies,\n            this.#contextValueOrFactory,\n            this.#topologicalOrder,\n            this.#tasks,\n            this.#taskDependencies,\n            onTasksCompleted,\n        );\n    }\n\n    /**\n     * Returns the number of tasks in the graph.\n     */\n    get size(): number {\n        return this.#tasks.size;\n    }\n\n    /**\n     * Topologically sorts the tasks in the graph, placing the sorted order in the `_topologicalOrder` array.\n     */\n    #topologicalSort() {\n        const visited = new Set<string>();\n        const temp = new Set<string>();\n\n        const visit = (taskId: string) => {\n            if (temp.has(taskId)) {\n                throw new Error(`Circular dependency detected involving task ${taskId}`);\n            }\n            if (!visited.has(taskId)) {\n                temp.add(taskId);\n                for (const depId of this.#taskDependencies.get(taskId)) {\n                    visit(depId);\n                }\n                temp.delete(taskId);\n                visited.add(taskId);\n                this.#topologicalOrder.push(taskId);\n            }\n        };\n\n        for (const taskId of this.#tasks.keys()) {\n            if (!visited.has(taskId)) {\n                visit(taskId);\n            }\n        }\n        visited.clear();\n        temp.clear();\n    }\n\n    // validate the dependencies object\n    #isValidDependencies(deps: unknown): deps is TTaskDependencies {\n        return (\n            typeof deps === \"object\" &&\n            deps !== null &&\n            !Array.isArray(deps) &&\n            Object.entries(deps).every(([key, value]) => typeof key === \"string\" && value !== undefined)\n        );\n    }\n}\n\n/**\n * Represents a task graph runner that executes tasks in a topologically sorted order.\n * It assumes the passed tasks are already topologically sorted.\n *\n * @template TTaskDependencies - Type of the dependencies each task will receive\n * @template TTaskContext - Type of the context each task will receive\n */\nexport class TaskGraphRunner<\n    TTaskDependencies extends Record<string, unknown>,\n    TInitialTaskContext,\n    TTaskContext extends Record<string, unknown> & { initial: unknown },\n> {\n    readonly #context = new Context<TInitialTaskContext, TTaskContext>();\n    readonly #dependencies: TTaskDependencies;\n    readonly #contextValueOrFactory:\n        | undefined\n        | TInitialTaskContext\n        | ((deps: TTaskDependencies) => DeepReadonly<TInitialTaskContext> | Promise<DeepReadonly<TInitialTaskContext>>);\n    readonly #topologicalOrder: string[];\n    readonly #tasks: Map<string, Task<TTaskDependencies, TTaskContext, unknown, string>>;\n    readonly #taskDependencies: DependencyMap;\n    readonly #onTasksCompleted?: (\n        ctx: TTaskContext,\n        deps: TTaskDependencies,\n        errors: TaskError[] | null,\n    ) => void | Promise<void>;\n    readonly #errors: TaskError[] = [];\n\n    constructor(\n        dependencies: TTaskDependencies,\n        contextValueOrFactory:\n            | undefined\n            | TInitialTaskContext\n            | ((\n                  deps: TTaskDependencies,\n              ) => DeepReadonly<TInitialTaskContext> | Promise<DeepReadonly<TInitialTaskContext>>),\n        topologicalOrder: string[],\n        tasks: Map<string, Task<TTaskDependencies, TTaskContext, unknown, string>>,\n        taskDependencies: DependencyMap,\n        onTasksCompleted?: (\n            ctx: TTaskContext,\n            deps: TTaskDependencies,\n            errors: TaskError[] | null,\n        ) => void | Promise<void>,\n    ) {\n        this.#dependencies = dependencies;\n        this.#contextValueOrFactory = contextValueOrFactory;\n        this.#topologicalOrder = topologicalOrder;\n        this.#tasks = tasks;\n        this.#taskDependencies = taskDependencies;\n        this.#onTasksCompleted = onTasksCompleted;\n    }\n\n    async #run(): Promise<TTaskContext> {\n        if (this.#topologicalOrder.length === 0) {\n            throw new Error(\"No tasks to run. Did you forget to call topologicalSort?\");\n        }\n        let value: TInitialTaskContext | undefined;\n        if (this.#contextValueOrFactory) {\n            value =\n                typeof this.#contextValueOrFactory === \"function\"\n                    ? await (\n                          this.#contextValueOrFactory as (\n                              deps: TTaskDependencies,\n                          ) => TInitialTaskContext | Promise<TInitialTaskContext>\n                      )(this.#dependencies)\n                    : this.#contextValueOrFactory;\n            this.#context.reset(value);\n        }\n\n        const completed = new Set<string>();\n        const running = new Map<string, Promise<void>>();\n        const readyTasks = new Set<string>(\n            this.#topologicalOrder.filter((taskId) => {\n                const task = this.#tasks.get(taskId);\n                if (!task) {\n                    throw new Error(`Task ${taskId} not found`);\n                }\n                return task.isEnabled && this.#taskDependencies.get(taskId).length === 0;\n            }),\n        );\n\n        const runTask = async (taskId: string) => {\n            const task = this.#tasks.get(taskId);\n            if (!task) {\n                throw new Error(`Task ${taskId} not found`);\n            }\n\n            try {\n                const result = await task.run(this.#dependencies, this.#context.value);\n                await this.#context.update({ [taskId]: result });\n                completed.add(taskId);\n            } catch (err) {\n                if (err instanceof Error) {\n                    this.#errors.push(new TaskError(taskId, err));\n                }\n                // completed in the sense that we won't try to run it again\n                completed.add(taskId);\n            } finally {\n                running.delete(taskId);\n\n                // Check if any dependent tasks are now ready to run\n                for (const [id, t] of this.#tasks) {\n                    if (!completed.has(id) && !running.has(id)) {\n                        const canRun =\n                            t.isEnabled &&\n                            this.#taskDependencies.get(t.id).every((depId) => {\n                                const depTask = this.#tasks.get(depId);\n                                return (\n                                    depTask &&\n                                    completed.has(depId) &&\n                                    depTask.status === \"completed\" &&\n                                    depTask.isEnabled\n                                );\n                            });\n                        if (canRun) {\n                            readyTasks.add(id);\n                        }\n                    }\n                }\n            }\n        };\n\n        while (completed.size < this.#tasks.size) {\n            // Start all ready tasks\n            for (const taskId of readyTasks) {\n                readyTasks.delete(taskId);\n                const promise = runTask(taskId);\n                running.set(taskId, promise);\n            }\n\n            // Wait for at least one task to complete\n            if (running.size > 0) {\n                await Promise.race(running.values());\n            } else {\n                // no tasks are running and we have not completed all tasks\n                // happens when tasks could not run due to failed dependencies\n                // or when there is a set of tasks that can not be run due to\n                // a disabled task\n                break;\n            }\n        }\n\n        if (this.#onTasksCompleted) {\n            await this.#onTasksCompleted(\n                this.#context.value,\n                this.#dependencies,\n                this.#errors.length > 0 ? this.#errors : null,\n            );\n        }\n\n        return this.#context.value;\n    }\n\n    /**\n     * Runs the tasks in the graph in topological order.\n     * Tasks are run concurrently when possible.\n     * In the event a task fails, other independent tasks will continue to run.\n     *\n     * @returns A promise that resolves to the completed context object when all tasks have completed.\n     */\n    async trigger(): Promise<TTaskContext> {\n        try {\n            return await this.#run();\n        } finally {\n            this.#context.reset(undefined);\n        }\n    }\n\n    printTaskGraph(): string {\n        if (this.#tasks.size === 0) {\n            return \"Empty task graph\";\n        }\n\n        const visited = new Set<string>();\n        const output: string[] = [];\n\n        // Helper function to create indentation\n        const getIndent = (level: number) => \"  \".repeat(level);\n\n        // Helper function to print a task and its dependencies recursively\n        const printTask = (taskId: string, level = 0, parentChain = new Set<string>()): void => {\n            if (parentChain.has(taskId)) {\n                output.push(`${getIndent(level)}${taskId} (circular dependency!)`);\n                return;\n            }\n\n            const task = this.#tasks.get(taskId);\n            if (!task) {\n                return;\n            }\n\n            // Mark as visited\n            visited.add(taskId);\n\n            // Print current task\n            const prefix = level === 0 ? \" \" : \" \";\n            output.push(`${getIndent(level)}${prefix}${taskId}${task.isEnabled ? \"\" : \" (Disabled)\"}`);\n\n            // Recursively print dependencies\n            const newParentChain = new Set(parentChain).add(taskId);\n            const dependencies = Array.from(this.#taskDependencies.get(task.id));\n\n            dependencies.forEach((depId, index) => {\n                if (!visited.has(depId)) {\n                    printTask(depId, level + 1, newParentChain);\n                } else {\n                    const prefix = index === dependencies.length - 1 ? \" \" : \" \";\n                    output.push(`${getIndent(level + 1)}${prefix}${depId} (already shown)`);\n                }\n            });\n        };\n\n        // Find root tasks (tasks with no dependencies)\n        const rootTasks = Array.from(this.#tasks.entries())\n            .filter(([_, task]) => this.#taskDependencies.get(task.id).length === 0)\n            .map(([id]) => id);\n\n        // Print starting from each root task\n        for (const taskId of rootTasks) {\n            if (!visited.has(taskId)) {\n                printTask(taskId);\n            }\n        }\n\n        // Print any remaining tasks that weren't reached\n        this.#tasks.forEach((_, taskId) => {\n            if (!visited.has(taskId)) {\n                printTask(taskId);\n            }\n        });\n\n        return output.join(\"\\n\");\n    }\n}\n"],"mappings":"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","names":["Croner","error","prefix"]}