{"version":3,"sources":["../src/task-graph.ts","../src/context.ts"],"sourcesContent":["import { promisify } from \"node:util\";\nimport { Context } from \"./context\";\n\nconst sleep = promisify(setTimeout);\n\nexport class TaskGraph<\n  TTaskDependencies extends Record<string, unknown> = Record<string, never>,\n  TTaskContext extends Record<string, unknown> & { initial: unknown } = { initial: unknown },\n> {\n  // start with an undefined context value (placed under key initial)\n  private _contextValueOrFactory: unknown = undefined;\n  // start with an empty dependencies object\n  private _dependencies: unknown = Object.create(null);\n\n  public finalize() {\n    // return a new instance of TaskGraph with the current state\n    return new TaskGraphBuilder<TTaskDependencies, TTaskContext>(\n      this._dependencies as TTaskDependencies,\n      this._contextValueOrFactory as undefined | TTaskContext | (() => TTaskContext | Promise<TTaskContext>),\n    );\n  }\n\n  public setContext<TNewContext>(valueOrFactory: TNewContext | (() => TNewContext | Promise<TNewContext>)) {\n    // set the context value to the provided value or factory\n    this._contextValueOrFactory = valueOrFactory;\n    // return the builder with the new context type\n    return this as unknown as TaskGraph<TTaskDependencies, { initial: TNewContext }>;\n  }\n\n  public setDependencies<TNewDependencies extends Record<string, unknown>>(value: TNewDependencies) {\n    if (typeof value !== \"object\" || value === null) throw new Error(\"Initial dependencies must be an object\");\n    // set the dependencies object to the provided value\n    this._dependencies = value as unknown as TTaskDependencies;\n    // return the builder with the new dependencies type\n    return this as unknown as TaskGraph<TNewDependencies, TTaskContext>;\n  }\n}\n\nclass TaskGraphBuilder<\n  TTaskDependencies extends Record<string, unknown>,\n  TTaskContext extends Record<string, unknown> & { initial: unknown },\n  TAllDependencyIds extends string = string & keyof Omit<TTaskContext, \"initial\">,\n> {\n  private readonly _tasks = new Map<string, Task<TTaskDependencies, TTaskContext, unknown, TAllDependencyIds>>();\n  private readonly _topologicalOrder: string[] = [];\n\n  constructor(\n    private _dependencies: TTaskDependencies,\n    private _contextValueOrFactory: undefined | TTaskContext | (() => TTaskContext | Promise<TTaskContext>),\n  ) {}\n\n  public addTask<TTaskId extends string, TTaskDependencyIds extends TAllDependencyIds, TTaskReturn>(\n    options: TaskOptions<TTaskId, TTaskDependencies, TTaskContext, TTaskReturn, TTaskDependencyIds>,\n  ) {\n    const taskId = options.id;\n    if (this._tasks.has(taskId)) throw new Error(`Task with id ${taskId} already exists`);\n    const task = new Task<TTaskDependencies, TTaskContext, TTaskReturn, TAllDependencyIds>(options);\n    this._tasks.set(taskId, task);\n\n    for (const depId of options.dependencies ?? []) {\n      if (typeof depId !== \"string\") throw new Error(\"Dependency ID must be a string\");\n      const dependentTask = this._tasks.get(depId);\n      if (!dependentTask) throw new Error(`Dependency ${depId} not found for task ${taskId}`);\n      task.addDependency(depId);\n    }\n\n    return this as unknown as TaskGraphBuilder<\n      TTaskDependencies,\n      TTaskContext &\n        Partial<{\n          [K in TTaskId]: TTaskReturn;\n        }>,\n      TAllDependencyIds | TTaskId\n    >;\n  }\n\n  public build() {\n    if (!this.size) throw new Error(\"Unable to build TaskGraphRunner. No tasks added to the graph\");\n    this._topologicalSort();\n    return new TaskGraphRunner(this._dependencies, this._contextValueOrFactory, this._topologicalOrder, this._tasks);\n  }\n\n  public get size() {\n    return this._tasks.size;\n  }\n\n  private _topologicalSort() {\n    const visited = new Set<string>();\n    const temp = new Set<string>();\n\n    const visit = (taskId: string) => {\n      if (temp.has(taskId)) throw new Error(`Circular dependency detected involving task ${taskId}`);\n      if (!visited.has(taskId)) {\n        temp.add(taskId);\n        const task = this._tasks.get(taskId);\n        if (!task) throw new Error(`Task ${taskId} not found`);\n        for (const depId of task.dependencies) visit(depId);\n        temp.delete(taskId);\n        visited.add(taskId);\n        this._topologicalOrder.push(taskId);\n      }\n    };\n\n    for (const taskId of this._tasks.keys()) if (!visited.has(taskId)) visit(taskId);\n    visited.clear();\n    temp.clear();\n  }\n}\n\nexport class TaskGraphRunner<\n  TTaskDependencies extends Record<string, unknown>,\n  TTaskContext extends Record<string, unknown> & { initial: unknown },\n> {\n  private readonly context = new Context<TTaskContext[\"initial\"], TTaskContext>();\n\n  constructor(\n    private _dependencies: TTaskDependencies,\n    private _contextValueOrFactory: undefined | TTaskContext | (() => TTaskContext | Promise<TTaskContext>),\n    private readonly _topologicalOrder: string[],\n    private readonly _tasks: Map<string, Task<TTaskDependencies, TTaskContext, unknown, string>>,\n  ) {}\n\n  run = async (): Promise<Required<TTaskContext>> => {\n    if (this._topologicalOrder.length === 0) {\n      throw new Error(\"No tasks to run. Did you forget to call topologicalSort?\");\n    }\n    let value: TTaskContext[\"initial\"] | undefined;\n    if (this._contextValueOrFactory) {\n      value =\n        typeof this._contextValueOrFactory === \"function\"\n          ? await (this._contextValueOrFactory as () => TTaskContext[\"initial\"] | Promise<TTaskContext[\"initial\"]>)()\n          : this._contextValueOrFactory;\n    }\n    this.context.reset(value);\n\n    const completed = new Set<string>();\n    const running = new Map<string, Promise<void>>();\n    const readyTasks = new Set<string>(\n      this._topologicalOrder.filter((taskId) => this._tasks.get(taskId)?.dependencies.length === 0),\n    );\n\n    const runTask = async (taskId: string) => {\n      const task = this._tasks.get(taskId);\n      if (!task) throw new Error(`Task ${taskId} not found`);\n\n      try {\n        const result = await task.run(this._dependencies, this.context.value);\n        await this.context.update({ [taskId]: result });\n        completed.add(taskId);\n      } catch {\n        // completed in the sense that we won't try to run it again\n        completed.add(taskId);\n      } finally {\n        running.delete(taskId);\n\n        // Check if any dependent tasks are now ready to run\n        for (const [id, t] of this._tasks) {\n          if (!completed.has(id) && !running.has(id)) {\n            const canRun = t.dependencies.every((depId) => {\n              const depTask = this._tasks.get(depId);\n              return depTask && completed.has(depId) && depTask.status === \"completed\";\n            });\n            if (canRun) readyTasks.add(id);\n          }\n        }\n      }\n    };\n\n    while (completed.size < this._tasks.size) {\n      // Start all ready tasks\n      for (const taskId of readyTasks) {\n        readyTasks.delete(taskId);\n        const promise = runTask(taskId);\n        running.set(taskId, promise);\n      }\n\n      // Wait for at least one task to complete\n      if (running.size > 0) {\n        await Promise.race(running.values());\n      } else {\n        // no tasks are running and we have not completed all tasks\n        // happens when tasks could not run due to failed dependencies\n        break;\n      }\n    }\n\n    return this.context.value as Required<TTaskContext>;\n  };\n}\n\nclass Task<\n  TTaskDependencies extends Record<string, unknown>,\n  TTaskContext extends Record<string, unknown> & { initial: unknown },\n  TTaskReturn,\n  TPossibleTaskId,\n> {\n  private readonly _dependencies: TPossibleTaskId[] = [];\n\n  private _retryPolicy: RetryPolicy = { maxRetries: 0, retryDelayMs: 0 };\n  private _status: TaskStatus = \"pending\";\n\n  constructor(private readonly options: TaskOptions<string, TTaskDependencies, TTaskContext, TTaskReturn, string>) {\n    if (options.retryPolicy) this._retryPolicy = options.retryPolicy;\n  }\n\n  public addDependency(taskId: TPossibleTaskId) {\n    this._dependencies.push(taskId);\n  }\n\n  public get dependencies() {\n    return this._dependencies;\n  }\n\n  public get id() {\n    return this.options.id;\n  }\n\n  public async run(deps: TTaskDependencies, ctx: TTaskContext): Promise<TTaskReturn> {\n    // we retry maxRetries times on top of the initial attempt\n    for (let attempt = 0; attempt < this._retryPolicy.maxRetries + 1; attempt++) {\n      try {\n        this._status = \"running\";\n        const result = await this.options.execute({ deps, ctx });\n        this._status = \"completed\";\n        return result;\n      } catch (err) {\n        if (attempt === this._retryPolicy.maxRetries) {\n          console.error(`Task failed after ${attempt + 1} attempts: ${err}`);\n          const error = err instanceof Error ? err : new Error(`Non error throw: ${String(err)}`);\n          try {\n            if (this.options.errorHandler) await this.options.errorHandler(error, { deps, ctx });\n            else console.error(`Error in task ${this.options.id}: ${err}`);\n          } catch (error) {\n            console.error(`Error in task error handler for ${this.options.id}: ${error}`);\n          }\n          this._status = \"failed\";\n          throw error;\n        }\n        console.error(`Task failed, retrying (attempt ${attempt + 1}/${this._retryPolicy.maxRetries}): ${err}`);\n        await sleep(this._retryPolicy.retryDelayMs);\n      }\n    }\n\n    // This line should never be reached due to the for loop condition,\n    // but TypeScript requires a return statement here\n    throw new Error(\"Unexpected end of run method\");\n  }\n\n  public get status() {\n    return this._status;\n  }\n}\n\ntype RetryPolicy = {\n  maxRetries: number;\n  retryDelayMs: number;\n};\n\ntype TaskOptions<\n  TTaskId extends string,\n  TTaskDependencies extends Record<string, unknown>,\n  TTaskContext extends Record<string, unknown> & { initial: unknown },\n  TTaskReturn,\n  TPossibleTaskDependencyId extends string = never,\n  TInput = { deps: TTaskDependencies; ctx: TTaskContext },\n> = {\n  id: TTaskId;\n  dependencies?: TPossibleTaskDependencyId[];\n  retryPolicy?: RetryPolicy;\n  execute: (input: TInput) => Promise<TTaskReturn> | TTaskReturn;\n  errorHandler?: (err: Error, input: TInput) => Promise<void> | void;\n};\n\ntype TaskStatus = \"pending\" | \"completed\" | \"failed\" | \"running\";\n","/**\n * Used to allow for the sharing of state between tasks.\n */\nexport class Context<TInitial, TContext> {\n  private object!: { initial: TInitial | undefined } & TContext;\n  private updateQueue: Promise<void>;\n\n  constructor(initialValue?: TInitial) {\n    this.reset(initialValue);\n    this.updateQueue = Promise.resolve();\n  }\n\n  /**\n   * Gets the current state of the managed object.\n   */\n  public get value(): { initial: TInitial | undefined } & TContext {\n    return this.object;\n  }\n\n  /**\n   * Resets the context to its initial state or a new initial object.\n   */\n  public reset(initialValue: TInitial | undefined): void {\n    if (initialValue !== undefined && initialValue !== null) {\n      this.object = { initial: initialValue } as {\n        initial: TInitial;\n      } & TContext;\n    } else {\n      this.object = { initial: undefined } as {\n        initial: TInitial | undefined;\n      } & TContext;\n    }\n  }\n\n  /**\n   * Asynchronously updates the context with new values. Ensures that updates are applied in the order they are called.\n   */\n  public update<NewValue extends object>(updateValue: NewValue): Promise<void> {\n    this.updateQueue = this.updateQueue.then(() => {\n      // overrides won't happen with how this is used since\n      // the initial context is under the key \"initial\"\n      // and all task results are under the unique id of that task\n      this.object = { ...this.object, ...updateValue };\n      return Promise.resolve();\n    });\n    return this.updateQueue;\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAA0B;;;ACGnB,IAAM,UAAN,MAAkC;AAAA,EAC/B;AAAA,EACA;AAAA,EAER,YAAY,cAAyB;AACnC,SAAK,MAAM,YAAY;AACvB,SAAK,cAAc,QAAQ,QAAQ;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA,EAKA,IAAW,QAAsD;AAC/D,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKO,MAAM,cAA0C;AACrD,QAAI,iBAAiB,UAAa,iBAAiB,MAAM;AACvD,WAAK,SAAS,EAAE,SAAS,aAAa;AAAA,IAGxC,OAAO;AACL,WAAK,SAAS,EAAE,SAAS,OAAU;AAAA,IAGrC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKO,OAAgC,aAAsC;AAC3E,SAAK,cAAc,KAAK,YAAY,KAAK,MAAM;AAI7C,WAAK,SAAS,EAAE,GAAG,KAAK,QAAQ,GAAG,YAAY;AAC/C,aAAO,QAAQ,QAAQ;AAAA,IACzB,CAAC;AACD,WAAO,KAAK;AAAA,EACd;AACF;;;AD5CA,IAAM,YAAQ,4BAAU,UAAU;AAE3B,IAAM,YAAN,MAGL;AAAA;AAAA,EAEQ,yBAAkC;AAAA;AAAA,EAElC,gBAAyB,uBAAO,OAAO,IAAI;AAAA,EAE5C,WAAW;AAEhB,WAAO,IAAI;AAAA,MACT,KAAK;AAAA,MACL,KAAK;AAAA,IACP;AAAA,EACF;AAAA,EAEO,WAAwB,gBAA0E;AAEvG,SAAK,yBAAyB;AAE9B,WAAO;AAAA,EACT;AAAA,EAEO,gBAAkE,OAAyB;AAChG,QAAI,OAAO,UAAU,YAAY,UAAU,KAAM,OAAM,IAAI,MAAM,wCAAwC;AAEzG,SAAK,gBAAgB;AAErB,WAAO;AAAA,EACT;AACF;AAEA,IAAM,mBAAN,MAIE;AAAA,EAIA,YACU,eACA,wBACR;AAFQ;AACA;AAAA,EACP;AAAA,EANc,SAAS,oBAAI,IAA+E;AAAA,EAC5F,oBAA8B,CAAC;AAAA,EAOzC,QACL,SACA;AACA,UAAM,SAAS,QAAQ;AACvB,QAAI,KAAK,OAAO,IAAI,MAAM,EAAG,OAAM,IAAI,MAAM,gBAAgB,MAAM,iBAAiB;AACpF,UAAM,OAAO,IAAI,KAAsE,OAAO;AAC9F,SAAK,OAAO,IAAI,QAAQ,IAAI;AAE5B,eAAW,SAAS,QAAQ,gBAAgB,CAAC,GAAG;AAC9C,UAAI,OAAO,UAAU,SAAU,OAAM,IAAI,MAAM,gCAAgC;AAC/E,YAAM,gBAAgB,KAAK,OAAO,IAAI,KAAK;AAC3C,UAAI,CAAC,cAAe,OAAM,IAAI,MAAM,cAAc,KAAK,uBAAuB,MAAM,EAAE;AACtF,WAAK,cAAc,KAAK;AAAA,IAC1B;AAEA,WAAO;AAAA,EAQT;AAAA,EAEO,QAAQ;AACb,QAAI,CAAC,KAAK,KAAM,OAAM,IAAI,MAAM,8DAA8D;AAC9F,SAAK,iBAAiB;AACtB,WAAO,IAAI,gBAAgB,KAAK,eAAe,KAAK,wBAAwB,KAAK,mBAAmB,KAAK,MAAM;AAAA,EACjH;AAAA,EAEA,IAAW,OAAO;AAChB,WAAO,KAAK,OAAO;AAAA,EACrB;AAAA,EAEQ,mBAAmB;AACzB,UAAM,UAAU,oBAAI,IAAY;AAChC,UAAM,OAAO,oBAAI,IAAY;AAE7B,UAAM,QAAQ,CAAC,WAAmB;AAChC,UAAI,KAAK,IAAI,MAAM,EAAG,OAAM,IAAI,MAAM,+CAA+C,MAAM,EAAE;AAC7F,UAAI,CAAC,QAAQ,IAAI,MAAM,GAAG;AACxB,aAAK,IAAI,MAAM;AACf,cAAM,OAAO,KAAK,OAAO,IAAI,MAAM;AACnC,YAAI,CAAC,KAAM,OAAM,IAAI,MAAM,QAAQ,MAAM,YAAY;AACrD,mBAAW,SAAS,KAAK,aAAc,OAAM,KAAK;AAClD,aAAK,OAAO,MAAM;AAClB,gBAAQ,IAAI,MAAM;AAClB,aAAK,kBAAkB,KAAK,MAAM;AAAA,MACpC;AAAA,IACF;AAEA,eAAW,UAAU,KAAK,OAAO,KAAK,EAAG,KAAI,CAAC,QAAQ,IAAI,MAAM,EAAG,OAAM,MAAM;AAC/E,YAAQ,MAAM;AACd,SAAK,MAAM;AAAA,EACb;AACF;AAEO,IAAM,kBAAN,MAGL;AAAA,EAGA,YACU,eACA,wBACS,mBACA,QACjB;AAJQ;AACA;AACS;AACA;AAAA,EAChB;AAAA,EAPc,UAAU,IAAI,QAA+C;AAAA,EAS9E,MAAM,YAA6C;AACjD,QAAI,KAAK,kBAAkB,WAAW,GAAG;AACvC,YAAM,IAAI,MAAM,0DAA0D;AAAA,IAC5E;AACA,QAAI;AACJ,QAAI,KAAK,wBAAwB;AAC/B,cACE,OAAO,KAAK,2BAA2B,aACnC,MAAO,KAAK,uBAA4F,IACxG,KAAK;AAAA,IACb;AACA,SAAK,QAAQ,MAAM,KAAK;AAExB,UAAM,YAAY,oBAAI,IAAY;AAClC,UAAM,UAAU,oBAAI,IAA2B;AAC/C,UAAM,aAAa,IAAI;AAAA,MACrB,KAAK,kBAAkB,OAAO,CAAC,WAAW,KAAK,OAAO,IAAI,MAAM,GAAG,aAAa,WAAW,CAAC;AAAA,IAC9F;AAEA,UAAM,UAAU,OAAO,WAAmB;AACxC,YAAM,OAAO,KAAK,OAAO,IAAI,MAAM;AACnC,UAAI,CAAC,KAAM,OAAM,IAAI,MAAM,QAAQ,MAAM,YAAY;AAErD,UAAI;AACF,cAAM,SAAS,MAAM,KAAK,IAAI,KAAK,eAAe,KAAK,QAAQ,KAAK;AACpE,cAAM,KAAK,QAAQ,OAAO,EAAE,CAAC,MAAM,GAAG,OAAO,CAAC;AAC9C,kBAAU,IAAI,MAAM;AAAA,MACtB,QAAQ;AAEN,kBAAU,IAAI,MAAM;AAAA,MACtB,UAAE;AACA,gBAAQ,OAAO,MAAM;AAGrB,mBAAW,CAAC,IAAI,CAAC,KAAK,KAAK,QAAQ;AACjC,cAAI,CAAC,UAAU,IAAI,EAAE,KAAK,CAAC,QAAQ,IAAI,EAAE,GAAG;AAC1C,kBAAM,SAAS,EAAE,aAAa,MAAM,CAAC,UAAU;AAC7C,oBAAM,UAAU,KAAK,OAAO,IAAI,KAAK;AACrC,qBAAO,WAAW,UAAU,IAAI,KAAK,KAAK,QAAQ,WAAW;AAAA,YAC/D,CAAC;AACD,gBAAI,OAAQ,YAAW,IAAI,EAAE;AAAA,UAC/B;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,WAAO,UAAU,OAAO,KAAK,OAAO,MAAM;AAExC,iBAAW,UAAU,YAAY;AAC/B,mBAAW,OAAO,MAAM;AACxB,cAAM,UAAU,QAAQ,MAAM;AAC9B,gBAAQ,IAAI,QAAQ,OAAO;AAAA,MAC7B;AAGA,UAAI,QAAQ,OAAO,GAAG;AACpB,cAAM,QAAQ,KAAK,QAAQ,OAAO,CAAC;AAAA,MACrC,OAAO;AAGL;AAAA,MACF;AAAA,IACF;AAEA,WAAO,KAAK,QAAQ;AAAA,EACtB;AACF;AAEA,IAAM,OAAN,MAKE;AAAA,EAMA,YAA6B,SAAoF;AAApF;AAC3B,QAAI,QAAQ,YAAa,MAAK,eAAe,QAAQ;AAAA,EACvD;AAAA,EAPiB,gBAAmC,CAAC;AAAA,EAE7C,eAA4B,EAAE,YAAY,GAAG,cAAc,EAAE;AAAA,EAC7D,UAAsB;AAAA,EAMvB,cAAc,QAAyB;AAC5C,SAAK,cAAc,KAAK,MAAM;AAAA,EAChC;AAAA,EAEA,IAAW,eAAe;AACxB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAW,KAAK;AACd,WAAO,KAAK,QAAQ;AAAA,EACtB;AAAA,EAEA,MAAa,IAAI,MAAyB,KAAyC;AAEjF,aAAS,UAAU,GAAG,UAAU,KAAK,aAAa,aAAa,GAAG,WAAW;AAC3E,UAAI;AACF,aAAK,UAAU;AACf,cAAM,SAAS,MAAM,KAAK,QAAQ,QAAQ,EAAE,MAAM,IAAI,CAAC;AACvD,aAAK,UAAU;AACf,eAAO;AAAA,MACT,SAAS,KAAK;AACZ,YAAI,YAAY,KAAK,aAAa,YAAY;AAC5C,kBAAQ,MAAM,qBAAqB,UAAU,CAAC,cAAc,GAAG,EAAE;AACjE,gBAAM,QAAQ,eAAe,QAAQ,MAAM,IAAI,MAAM,oBAAoB,OAAO,GAAG,CAAC,EAAE;AACtF,cAAI;AACF,gBAAI,KAAK,QAAQ,aAAc,OAAM,KAAK,QAAQ,aAAa,OAAO,EAAE,MAAM,IAAI,CAAC;AAAA,gBAC9E,SAAQ,MAAM,iBAAiB,KAAK,QAAQ,EAAE,KAAK,GAAG,EAAE;AAAA,UAC/D,SAASA,QAAO;AACd,oBAAQ,MAAM,mCAAmC,KAAK,QAAQ,EAAE,KAAKA,MAAK,EAAE;AAAA,UAC9E;AACA,eAAK,UAAU;AACf,gBAAM;AAAA,QACR;AACA,gBAAQ,MAAM,kCAAkC,UAAU,CAAC,IAAI,KAAK,aAAa,UAAU,MAAM,GAAG,EAAE;AACtG,cAAM,MAAM,KAAK,aAAa,YAAY;AAAA,MAC5C;AAAA,IACF;AAIA,UAAM,IAAI,MAAM,8BAA8B;AAAA,EAChD;AAAA,EAEA,IAAW,SAAS;AAClB,WAAO,KAAK;AAAA,EACd;AACF;","names":["error"]}