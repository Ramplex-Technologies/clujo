{"version":3,"sources":["../src/task-graph.ts","../src/context.ts"],"sourcesContent":["import { Context } from \"./context\";\nimport type { ITask, ITaskGraph } from \"./task-graph.types\";\n\nexport class TaskGraph<TDependencies, TContext extends object> implements ITaskGraph<TContext> {\n  private readonly context: Context<TContext> = new Context<TContext>();\n\n  constructor(\n    private readonly taskDependencies: TDependencies,\n    private readonly contextValueOrFactory: undefined | TContext | (() => TContext | Promise<TContext>),\n    private readonly tasks: Map<string, ITask<TDependencies, TContext, unknown>>,\n    private readonly order: string[],\n  ) {}\n\n  run = async (): Promise<Required<TContext>> => {\n    if (this.order.length === 0) throw new Error(\"No tasks to run. Did you forget to call topologicalSort?\");\n    let value: TContext | undefined;\n    if (this.contextValueOrFactory) {\n      value =\n        typeof this.contextValueOrFactory === \"function\"\n          ? await this.contextValueOrFactory()\n          : this.contextValueOrFactory;\n    }\n    this.context.reset(value);\n\n    const completed = new Set<string>();\n    const running = new Map<string, Promise<void>>();\n    const readyTasks = new Set<string>(\n      this.order.filter((taskId) => this.tasks.get(taskId)?.dependencies.length === 0),\n    );\n\n    const runTask = async (taskId: string) => {\n      const task = this.tasks.get(taskId);\n      if (!task) throw new Error(`Task ${taskId} not found`);\n\n      try {\n        const result = await task.run(this.taskDependencies, this.context.value);\n        await this.context.update({ [taskId]: result });\n        completed.add(taskId);\n      } catch {\n        // completed in the sense that we won't try to run it again\n        completed.add(taskId);\n      } finally {\n        running.delete(taskId);\n\n        // Check if any dependent tasks are now ready to run\n        for (const [id, t] of this.tasks) {\n          if (!completed.has(id) && !running.has(id)) {\n            const canRun = t.dependencies.every((depId) => {\n              const depTask = this.tasks.get(depId);\n              return depTask && completed.has(depId) && depTask.status === \"completed\";\n            });\n            if (canRun) readyTasks.add(id);\n          }\n        }\n      }\n    };\n\n    while (completed.size < this.tasks.size) {\n      // Start all ready tasks\n      for (const taskId of readyTasks) {\n        readyTasks.delete(taskId);\n        const promise = runTask(taskId);\n        running.set(taskId, promise);\n      }\n\n      // Wait for at least one task to complete\n      if (running.size > 0) {\n        await Promise.race(running.values());\n      } else {\n        // no tasks are running and we have not completed all tasks\n        // happens when tasks could not run due to failed dependencies\n        break;\n      }\n    }\n\n    return this.context.value as Required<TContext>;\n  };\n}\n","/**\n * Used to allow for the sharing of state between tasks.\n */\nexport class Context<T extends object> {\n  private object!: { initial: object | undefined } & T;\n  private updateQueue: Promise<void>;\n\n  constructor(initialObject?: object) {\n    this.reset(initialObject);\n    this.updateQueue = Promise.resolve();\n  }\n\n  /**\n   * Gets the current state of the managed object.\n   */\n  public get value(): { initial: object | undefined } & T {\n    return this.object;\n  }\n\n  /**\n   * Resets the context to its initial state or a new initial object.\n   */\n  public reset(initialObject?: object): void {\n    if (initialObject) {\n      this.object = { initial: { ...initialObject } } as {\n        initial: object | undefined;\n      } & T;\n    } else {\n      this.object = { initial: undefined } as {\n        initial: object | undefined;\n      } & T;\n    }\n  }\n\n  /**\n   * Asynchronously updates the context with new values. Ensures that updates are applied in the order they are called.\n   */\n  public update<NewValue extends object>(updateValue: NewValue): Promise<void> {\n    this.updateQueue = this.updateQueue.then(() => {\n      // overrides won't happen with how this is used since\n      // the initial context is under the key \"initial\"\n      // and all task results are under the unique id of that task\n      this.object = { ...this.object, ...updateValue };\n      return Promise.resolve();\n    });\n    return this.updateQueue;\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACGO,IAAM,UAAN,MAAgC;AAAA,EAIrC,YAAY,eAAwB;AAClC,SAAK,MAAM,aAAa;AACxB,SAAK,cAAc,QAAQ,QAAQ;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA,EAKA,IAAW,QAA6C;AACtD,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKO,MAAM,eAA8B;AACzC,QAAI,eAAe;AACjB,WAAK,SAAS,EAAE,SAAS,EAAE,GAAG,cAAc,EAAE;AAAA,IAGhD,OAAO;AACL,WAAK,SAAS,EAAE,SAAS,OAAU;AAAA,IAGrC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKO,OAAgC,aAAsC;AAC3E,SAAK,cAAc,KAAK,YAAY,KAAK,MAAM;AAI7C,WAAK,SAAS,EAAE,GAAG,KAAK,QAAQ,GAAG,YAAY;AAC/C,aAAO,QAAQ,QAAQ;AAAA,IACzB,CAAC;AACD,WAAO,KAAK;AAAA,EACd;AACF;;;AD5CO,IAAM,YAAN,MAAwF;AAAA,EAG7F,YACmB,kBACA,uBACA,OACA,OACjB;AAJiB;AACA;AACA;AACA;AANnB,SAAiB,UAA6B,IAAI,QAAkB;AASpE,eAAM,YAAyC;AAC7C,UAAI,KAAK,MAAM,WAAW,EAAG,OAAM,IAAI,MAAM,0DAA0D;AACvG,UAAI;AACJ,UAAI,KAAK,uBAAuB;AAC9B,gBACE,OAAO,KAAK,0BAA0B,aAClC,MAAM,KAAK,sBAAsB,IACjC,KAAK;AAAA,MACb;AACA,WAAK,QAAQ,MAAM,KAAK;AAExB,YAAM,YAAY,oBAAI,IAAY;AAClC,YAAM,UAAU,oBAAI,IAA2B;AAC/C,YAAM,aAAa,IAAI;AAAA,QACrB,KAAK,MAAM,OAAO,CAAC,WAAW,KAAK,MAAM,IAAI,MAAM,GAAG,aAAa,WAAW,CAAC;AAAA,MACjF;AAEA,YAAM,UAAU,OAAO,WAAmB;AACxC,cAAM,OAAO,KAAK,MAAM,IAAI,MAAM;AAClC,YAAI,CAAC,KAAM,OAAM,IAAI,MAAM,QAAQ,MAAM,YAAY;AAErD,YAAI;AACF,gBAAM,SAAS,MAAM,KAAK,IAAI,KAAK,kBAAkB,KAAK,QAAQ,KAAK;AACvE,gBAAM,KAAK,QAAQ,OAAO,EAAE,CAAC,MAAM,GAAG,OAAO,CAAC;AAC9C,oBAAU,IAAI,MAAM;AAAA,QACtB,QAAQ;AAEN,oBAAU,IAAI,MAAM;AAAA,QACtB,UAAE;AACA,kBAAQ,OAAO,MAAM;AAGrB,qBAAW,CAAC,IAAI,CAAC,KAAK,KAAK,OAAO;AAChC,gBAAI,CAAC,UAAU,IAAI,EAAE,KAAK,CAAC,QAAQ,IAAI,EAAE,GAAG;AAC1C,oBAAM,SAAS,EAAE,aAAa,MAAM,CAAC,UAAU;AAC7C,sBAAM,UAAU,KAAK,MAAM,IAAI,KAAK;AACpC,uBAAO,WAAW,UAAU,IAAI,KAAK,KAAK,QAAQ,WAAW;AAAA,cAC/D,CAAC;AACD,kBAAI,OAAQ,YAAW,IAAI,EAAE;AAAA,YAC/B;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,aAAO,UAAU,OAAO,KAAK,MAAM,MAAM;AAEvC,mBAAW,UAAU,YAAY;AAC/B,qBAAW,OAAO,MAAM;AACxB,gBAAM,UAAU,QAAQ,MAAM;AAC9B,kBAAQ,IAAI,QAAQ,OAAO;AAAA,QAC7B;AAGA,YAAI,QAAQ,OAAO,GAAG;AACpB,gBAAM,QAAQ,KAAK,QAAQ,OAAO,CAAC;AAAA,QACrC,OAAO;AAGL;AAAA,QACF;AAAA,MACF;AAEA,aAAO,KAAK,QAAQ;AAAA,IACtB;AAAA,EAjEG;AAkEL;","names":[]}